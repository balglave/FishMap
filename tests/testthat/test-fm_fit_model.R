# WARNING - Generated by {fusen} from /dev/flat_fm_fit_model.Rmd: do not edit by hand

test_that("fm_fit_model works", {
  
  
  # You can test your model for small datas or big datas. You must run the tests locally with FISHMAP_UPDATE_OUTPUTS env at TRUE to store the rds file.
  
  test_resolution <- Sys.getenv("FISHMAP_TEST_RESOLUTION", unset = "small")
  
  if(test_resolution == "small"){
    fm_data_inputs <- readr::read_rds(system.file("examples", "part1_output_small.rds", package = "FishMap"))
  }else if (test_resolution == "big") {
    ## TODO use correct params for line below
    # fm_data_inputs <- fm_load_data(k = 0.75, month_start = 10, month_end = 12, ...)
  }
  
  
  
  # run part2
  withr::with_seed(1234,{
    

  fm_model_results <- fm_fit_model(fm_data_inputs = fm_data_inputs,
                                   SE = 1,
                                   data_source = 1,
                                   data_obs = 2,
                                   samp_process = 0,
                                   b_constraint = 2,
                                   cov_samp_process = 0,
                                   biomass_temporal = 1,
                                   sampling_temporal = 0,
                                   lf_link = 0,
                                   ref_data = "com",
                                   EM = "est_b",
                                   month_ref = 1)
  
  })
  
  # Update expected outputs here
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    # save output depending if we are in flat or in test
    output_inst_dir <- here::here("inst", "examples") 
    
    if (test_resolution == "small") {
      readr::write_rds(x = fm_model_results,
                       file = file.path(output_inst_dir, paste0("part2_output_", test_resolution , ".rds")))
    }else if (test_resolution == "big") {
      ## TODO what we need to check
    }
    
  }
  
  # check output is saved as rds
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    
    
    output_inst_dir <- here::here("inst", "examples")
    
    #' @description Test to check if we can save output
    expect_true(file.exists(file.path(output_inst_dir, paste0("part2_output_", test_resolution , ".rds"))))
  }
  
  # Check resultats of model 
  
  #' @description Testing the result of `fm_fit_model` is a list
  expect_type(object = fm_model_results,  "list")
  
  #' @description Testing names of the list return by `fm_fit_model` 
  expect_named(
    object = fm_model_results, 
    expected = c(
      "time.step_df", 
      "loc_x" ,      
      "report" ,   
      "samp_process", 
      "converge" )
  )
  
  
  #' @description Testing types inside the list return by `fm_fit_model` 
  expect_s3_class(fm_model_results$time.step_df, "data.frame")
  expect_s3_class(fm_model_results$loc_x, "data.frame")
  expect_type(fm_model_results$report, "list")
  expect_type(fm_model_results$samp_process, "double")
  expect_type(fm_model_results$converge, "integer")
  
  # Testing for small model
  
  if(test_resolution == "small"){
    
    expected_outputs <- readr::read_rds(
      system.file(
        "examples",
        paste0("part2_output_", test_resolution , ".rds"),
        package = "FishMap")
    )
    
    
    # sort list and data frame elements to avoid order discrepancies
    resort_all <- function(x) {
      x <- x[sort(names(x))]
      
      result <- lapply(x, function(x) {
        if (inherits(x, c("data.frame", 'list'))) {
          x[sort(names(x))]
        } else{
          x
        }
      })
      
      result
    }
    
    resorted_result <- resort_all(fm_model_results)
    resorted_expected <- resort_all(expected_outputs)
    
    # remove name attributes (likely generated by a specific version of {sf})
    attr(resorted_result$loc_x$long, which = "names") <- NULL
    attr(resorted_result$loc_x$lati, which = "names") <- NULL
    attr(resorted_expected$loc_x$long, which = "names") <- NULL
    attr(resorted_expected$loc_x$lati, which = "names") <- NULL
    
    #' @description Testing that the result of `fm_fit_model` is stable
    expect_equal(
      object = resorted_result,
      expected = resorted_expected,
      tolerance = 1e-4
    )
  }
  
})
