---
title: "flat_fm_load_data.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
library(dplyr)
library(INLA)
library(ggplot2)
library(sf)
library(stringr)
library(tidyr)
library(TMB)
library(tictoc)
library(testthat)
library(withr)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# subfunctions of `fm_load_data()`

## `fm_build_domain_mesh_spde()`: Build spatial domain and mesh

This function will construct the mesh of the spatial domain.

```{r function-fm_build_domain_mesh_spde}
#' Build spatial domain and mesh
#' 
#' @importFrom dplyr mutate select
#' @importFrom INLA inla.nonconvex.hull inla.mesh.2d inla.CRS inla.spde2.matern inla.mesh.create inla.spde.make.A
#' @importFrom sf st_as_sf st_intersects st_join st_coordinates
#' @importFrom sp SpatialPointsDataFrame CRS
#' @importFrom methods as
#' 
#' @inheritParams fm_load_data
#' @param grid_limit extent object Limits of the grid for the spatial domain
#' @param resol numeric Resolution of the discretization grid
#' @param grid_projection character A character string of projection arguments for `sp::CRS()`
#' @param study_domain sf data.frame Study_domain object
#' @param create_mesh character Method for creating mesh (either `from_shapefile` the mesh will be more regular on the grid or `from_data` the mesh will be denser in the areas where there are data). Default is `from_shapefile`
#' @param k k
#' @param vmslogbook_data data.frame Commercial (vmslogbook) data
#' @param study_domain_sf sf data.frame Study domain object, used when mesh is created from data
#' @param Alpha numeric Fractional operator order for `inla.spde2.matern()`
#' 
#' @return list A named list
#' 
#' @noRd
fm_build_domain_mesh_spde <- function(
    grid_limit,
    resol,
    grid_projection,
    study_domain,
    create_mesh = c("from_shapefile", "from_data"),
    k,
    vmslogbook_data,
    study_domain_sf,
    Alpha
    ) {
  
  # Check create_mesh value
  create_mesh <- match.arg(create_mesh)
  
  ## Build regular grid objects
  # Create raster of the grid
  grid <- raster::raster(grid_limit,res = resol,crs = grid_projection)
  
  # Create spatialpolygon based on raster
  gridpolygon <- raster::rasterToPolygons(grid)
  gridpolygon$layer <- c(1:length(gridpolygon$layer))
  gridpolygon_sf <- st_as_sf(gridpolygon)
  
  # Create spatial points based on raster
  raster_to_point <- raster::rasterToPoints(grid)
  datapoint <- SpatialPointsDataFrame(coords=raster_to_point,
                                      data=data.frame(layer = 1:nrow(raster_to_point)),
                                      proj4string=CRS(grid_projection))
  datapoint_sf <- st_as_sf(datapoint)
  datapoint_sf_2 <- datapoint_sf[st_intersects(datapoint_sf,study_domain) %>% lengths > 0,]
  
  # Cross grid with study domain
  datapoint_sf_2 <- st_join(datapoint_sf_2,study_domain)
  datapoint_2 <- datapoint_sf_2 %>%
    mutate(long = st_coordinates(.)[,1],
           lati = st_coordinates(.)[,2]) %>%
    as.data.frame %>%
    dplyr::select(-geometry)
  loc_x <- datapoint_2 %>% mutate(cell = 1:nrow(datapoint_2))
  
  ## Build mesh
  # mesh boundary
  bound <- inla.nonconvex.hull(unique(as.matrix(datapoint_2[,c("long","lati")])),convex=-0.05)
  bound2 <- inla.nonconvex.hull(unique(as.matrix(datapoint_2[,c("long","lati")])),convex=-0.2)
  
  # create mesh
  if(create_mesh == "from_shapefile"){
    
    mesh <- inla.mesh.2d(
      loc=as.matrix(datapoint_2[,c("long","lati")]), ## provide locations or domain
      boundary=list(bound,bound2),
      max.edge=c(1/k, 2/k), ## mandatory
      cutoff=0.1/k,crs = inla.CRS(projargs = CRS(grid_projection))) ## good to have >0
    
  }else if(create_mesh == "from_data"){
    
    ptvms_wgs84_sf <- st_as_sf(vmslogbook_data,coords = c("long","lati"),crs=grid_projection)
    ptvms_wgs84_sf_2 <- ptvms_wgs84_sf[st_intersects(ptvms_wgs84_sf,study_domain_sf) %>% lengths > 0,]
    ptvms_wgs84_sf_2 <- st_join(ptvms_wgs84_sf_2,study_domain_sf)
    
    mesh <- inla.mesh.2d(
      as.matrix(st_coordinates(ptvms_wgs84_sf_2)), ## provide locations or domain
      boundary=list(bound,bound2),
      max.edge=c(1/k, 2/k), ## mandatory
      cutoff=0.1/k)
    
  }
  
  ## Anisotropic objects
  anisotropic_mesh <- mesh
  Dset = 1:2
  # Triangle info
  TV = anisotropic_mesh$graph$tv       # Triangle to vertex indexing
  V0 = anisotropic_mesh$loc[TV[,1],Dset]   # V = vertices for each triangle
  V1 = anisotropic_mesh$loc[TV[,2],Dset]
  V2 = anisotropic_mesh$loc[TV[,3],Dset]
  E0 = V2 - V1                      # E = edge for each triangle
  E1 = V0 - V2
  E2 = V1 - V0
  Tri_Area = rep(NA, nrow(E0))
  crossprod_fn = function(Vec1,Vec2) abs(det( rbind(Vec1,Vec2) ))
  for(i in 1:length(Tri_Area)) Tri_Area[i] = crossprod_fn( E0[i,],E1[i,] )/2   # T = area of each triangle
  anisotropic_spde = inla.spde2.matern(anisotropic_mesh, alpha=2)
  MeshList_aniso <- list(anisotropic_spde = anisotropic_spde,
                         Tri_Area = Tri_Area,
                         E0 = E0,
                         E1 = E1,
                         E2 = E2,
                         TV = TV)
  
  ## SPDE objects
  spde <- (inla.spde2.matern(mesh, alpha=Alpha)$param.inla)[c("M0","M1","M2")]
  
  ## Prediction mesh and related spde objects
  mesh_pred <- inla.mesh.create( loc_x[,c('long','lati')] )
  W <- rep(1,nrow(loc_x))
  W <- c(W,rep(0,mesh_pred$n - nrow(loc_x)))
  
  A <- inla.spde.make.A(mesh, loc=as.matrix(loc_x[,c("long","lati")] ))
  A <- as( A, "dgTMatrix" )
  Aix_ij_pred <- cbind(A@i,A@j)
  Aix_ij_pred <- Aix_ij_pred[1:(nrow(loc_x)*3),]
  Aix_w_pred <- A@x
  
  # Return named list as output
  return(
    list(
      "mesh" = mesh,
      "loc_x" = loc_x,
      "spde" = spde,
      "Aix_ij_pred" = Aix_ij_pred,
      "Aix_w_pred" = Aix_w_pred,
      "W" = W,
      "MeshList_aniso" = MeshList_aniso,
      "gridpolygon_sf" = gridpolygon_sf
    )
  )
}
```

```{r example-fm_build_domain_mesh_spde, eval = FALSE}
#' \dontrun{
#fm_build_domain_mesh_spde(
#     grid_limit = grid_limit,
#     resol = resol,
#     grid_projection = grid_projection,
#     study_domain = study_domain,
#     create_mesh = create_mesh,
#     k = k,
#     vmslogbook_data = vmslogbook_data,
#     study_domain_sf = study_domain_sf,
#     Alpha = Alpha
#     )
#' }
```
  
```{r tests-fm_build_domain_mesh_spde}
test_that("fm_build_domain_mesh_spde works", {
  
  ## prepare inputs
  # vms data - unfiltered
  vmslogbook_data_file <- system.file("original_data",
                                      "Solea_solea",
                                      "vmslogbook_data.Rdata",
                                      package = "FishMap"
  )
  load(vmslogbook_data_file)
  
  # filter vms data as done in `fm_load_data()`
  fleet <- c("OTB_DEF_>=70_0","OTB_CEP_>=70_0","OTT_DEF_>=70_0")
  select_aggreg_level <- paste(fleet,collapse = "|")
  vmslogbook_data <- vmslogbook_data %>%
    filter(str_detect(LE_MET_level6,select_aggreg_level))
  vmslogbook_data$LE_MET_level6 <- factor(as.character(vmslogbook_data$LE_MET_level6),levels = fleet)
  vmslogbook_data_0 <- vmslogbook_data %>% ungroup %>% dplyr::select(-layer)
  
  # study domain
  study_domain_file <- system.file("original_data",
                                   "Solea_solea",
                                   "study_domain.Rdata",
                                   package = "FishMap"
  )
  load(study_domain_file)
  
  # mesh grid
  grid_limit <- raster::extent(c(-6, 0, 42, 48))
  
  ## run function
  result <- fm_build_domain_mesh_spde(
    grid_limit = grid_limit,
    resol = 0.05,
    grid_projection = "+proj=longlat +datum=WGS84",
    study_domain = study_domain,
    create_mesh = "from_shapefile",
    k = 0.25,
    vmslogbook_data,
    study_domain_sf = NULL,
    Alpha = 2)
  
  ## test outputs
  #' @description Testing that fm_build_domain_mesh_spde returns a list
  expect_type(object = result,
              type = "list")
  
  #' @description Testing names of the list
  expect_named(object = result,
               expected = c("mesh",
                            "loc_x",
                            "spde",
                            "Aix_ij_pred",
                            "Aix_w_pred",
                            "W",
                            "MeshList_aniso",
                            "gridpolygon_sf")
  )
  
  #' @description Testing types inside the list
  expect_type(result[["mesh"]], "list")
  expect_type(result[["loc_x"]], "list")
  expect_type(result[["spde"]], "list")
  expect_type(result[["Aix_ij_pred"]], "integer")
  expect_type(result[["Aix_w_pred"]], "double")
  expect_type(result[["W"]], "double")
  expect_type(result[["MeshList_aniso"]], "list")
  expect_type(result[["gridpolygon_sf"]], "list")
}
)
```

## `fm_shape_sci_data_st()` : Shape scientific data

This fonction will shape the scientific data according to the selected time window and time step.
    
```{r function-fm_shape_sci_data_st}
#' Shape scientific data
#' 
#' @importFrom dplyr mutate inner_join ungroup select
#' @importFrom INLA inla.spde.make.A
#' @importFrom sf st_as_sf st_intersects st_join st_coordinates
#' 
#' @param survey_data_0 tibble Scientific data
#' @param time.step_df data.frame Time window used
#' @param grid_projection character A character string of projection arguments for `sp::CRS()`
#' @param gridpolygon_sf sf data.frame Spatialpolygon based on raster
#' @param scientific_observation character Measure unit of scientific observation (either `CPUE` or `Density`). Default is `CPUE`
#' @param Sci.obs_spp data.frame Scientific observation data, used when scientific observation unit is `Density`
#' @param mesh inla.mesh Spatial grid of observations
#' 
#' @return list A named list
#' 
#' @noRd
fm_shape_sci_data_st <- function(
    survey_data_0,
    time.step_df,
    grid_projection,
    gridpolygon_sf,
    scientific_observation = c("CPUE", "Density"),
    Sci.obs_spp,
    mesh
    ) {
  ## Shape date columns
  survey_data_0$Month <- as.character(survey_data_0$Month)
  survey_data_0$Year <- as.character(survey_data_0$Year)
  
  ## Join scientific data with time step data frame
  survey_data_1 <- survey_data_0 %>%
    mutate(Month = ifelse(Month %in% paste0(1:9),
                          paste0("0",Month),paste0(Month))) %>%
    inner_join(time.step_df)
  
  ## Convert commercial data into sf object to intersect with gridpolygon
  survey_data_sf <- st_as_sf(survey_data_1,
                            coords = c("long","lati"),
                            crs = grid_projection) %>%
    ungroup()
  
  ## Discretize scientific data
  survey_data_sf <- survey_data_sf[st_intersects(survey_data_sf,gridpolygon_sf) %>% lengths > 0,]
  survey_data_2 <- st_join(survey_data_sf,gridpolygon_sf) %>%
    mutate(long = st_coordinates(.)[,1],
           lati = st_coordinates(.)[,2]) %>%
    as.data.frame() %>%
    dplyr::select(-geometry)
  
  if(scientific_observation == "Density") survey_data_2$Sci.obs_spp <- Sci.obs_spp$CatchWgt_spp/Sci.obs_spp$SweptArea_km2
  if(scientific_observation == "CPUE") survey_data_2$Sci.obs_spp <- survey_data_2$CatchWgt_spp/survey_data_2$HaulDur
  
  y_sci_i <- survey_data_2$Sci.obs_spp # scientific observation
  t_sci_i <- survey_data_2$t # time step
  
  ## Mesh objects for scientific data
  A <- inla.spde.make.A(mesh, loc=as.matrix(survey_data_2[,c("long","lati")] ))
  A <- as( A, "dgTMatrix")
  Aix_ij_sci <- cbind(A@i,A@j)
  Aix_w_sci <- A@x
  
  # Return named list as output
  return(
    list(
      "y_sci_i" = y_sci_i,
      "t_sci_i" = t_sci_i,
      "Aix_ij_sci" = Aix_ij_sci,
      "Aix_w_sci" = Aix_w_sci,
      "survey_data_2" = survey_data_2
    )
  )
}
```
  
```{r example-fm_shape_sci_data_st, eval = FALSE}
#' \dontrun{
# fm_shape_sci_data_st(
#   survey_data_0 = survey_data_0,
#   time.step_df = time.step_df,
#   grid_projection = "+proj=longlat +datum=WGS84",
#   gridpolygon_sf = domain_mesh_spde_outputs[["gridpolygon_sf"]],
#   scientific_observation = "CPUE",
#   Sci.obs_spp = NULL,
#   mesh = domain_mesh_spde_outputs[["mesh"]]
# )
#' }
```
  
```{r tests-fm_shape_sci_data_st}
test_that("fm_shape_sci_data_st works", {
  
  ## prepare inputs
  # vms data - unfiltered
  vmslogbook_data_file <- system.file("original_data",
                                      "Solea_solea",
                                      "vmslogbook_data.Rdata",
                                      package = "FishMap"
  )
  load(vmslogbook_data_file)
  
  # filter vms data as done in `fm_load_data()`
  fleet <- c("OTB_DEF_>=70_0","OTB_CEP_>=70_0","OTT_DEF_>=70_0")
  select_aggreg_level <- paste(fleet,collapse = "|")
  vmslogbook_data <- vmslogbook_data %>%
    filter(str_detect(LE_MET_level6,select_aggreg_level))
  vmslogbook_data$LE_MET_level6 <- factor(as.character(vmslogbook_data$LE_MET_level6),levels = fleet)
  vmslogbook_data_0 <- vmslogbook_data %>% ungroup %>% dplyr::select(-layer)
  
  # study domain
  study_domain_file <- system.file("original_data",
                                   "Solea_solea",
                                   "study_domain.Rdata",
                                   package = "FishMap"
  )
  load(study_domain_file)

  # mesh grid
  grid_limit <- raster::extent(c(-6, 0, 42, 48))
  
  # `fm_build_domain_mesh_spde()` call
  domain_mesh_spde_outputs <- fm_build_domain_mesh_spde(
    grid_limit = grid_limit,
    resol = 0.05,
    grid_projection = "+proj=longlat +datum=WGS84",
    study_domain = study_domain,
    create_mesh = "from_shapefile",
    k = 0.25,
    vmslogbook_data,
    study_domain_sf = NULL,
    Alpha = 2)
  
  # survey data
  survey_data_file <- system.file("original_data",
                                "Solea_solea",
                                "survey_data.Rdata",
                                package = "FishMap"
                                )
  load(survey_data_file)
  survey_data_0 <- survey_data %>% ungroup %>% dplyr::select(-layer)
  
  # time df
  year_vec <- 2018:2018
  month_vec <- 11:11
  time.step_df <- expand.grid(month_vec,year_vec)
  colnames(time.step_df) <- c("Month","Year")
  time.step_df <- time.step_df %>%
    arrange(Year,Month) %>%
    mutate(Month = ifelse(Month < 10,paste0("0",Month),Month)) %>%
    mutate(Year_Month = paste0(Year,"_",Month)) %>%
    mutate(t = 1:nrow(time.step_df))
  time.step_df$Year <- as.character(time.step_df$Year)
  time.step_df$Month <- as.character(time.step_df$Month)
    
  ## run function
  result <- fm_shape_sci_data_st(
    survey_data_0 = survey_data_0,
    time.step_df = time.step_df,
    grid_projection = "+proj=longlat +datum=WGS84",
    gridpolygon_sf = domain_mesh_spde_outputs[["gridpolygon_sf"]],
    scientific_observation = "CPUE",
    Sci.obs_spp = NULL,
    mesh = domain_mesh_spde_outputs[["mesh"]]
    )
  
  ## test outputs
  #' @description Testing that fm_shape_sci_data_st returns a list
  expect_type(object = result,
              type = "list")
  
  #' @description Testing names of the list
  expect_named(object = result,
               expected = c("y_sci_i",
                            "t_sci_i",
                            "Aix_ij_sci",
                            "Aix_w_sci",
                            "survey_data_2"
                            )
               )
  
  #' @description Testing types inside the list
  expect_type(result[["y_sci_i"]], "double")
  expect_type(result[["t_sci_i"]], "integer")
  expect_type(result[["Aix_ij_sci"]], "integer")
  expect_type(result[["Aix_w_sci"]], "double")
  expect_type(result[["survey_data_2"]], "list")

})
```
  
## `fm_shape_vms_logbook_data_st()` : Shape 'VMS x logbook' data
    
```{r function-fm_shape_vms_logbook_data_st}
#' Shape 'VMS x logbook' data
#' 
#' @importFrom dplyr inner_join mutate select filter group_by count arrange full_join ungroup
#' @importFrom INLA inla.spde.make.A
#' @importFrom sf st_as_sf st_intersects st_join st_coordinates
#' @importFrom tidyr pivot_wider
#' 
#' @param vmslogbook_data_0 tibble VMS x LogBook data
#' @param time.step_df data.frame Time window used
#' @param grid_projection character A character string of projection arguments for `sp::CRS()`
#' @param gridpolygon_sf sf data.frame Spatialpolygon based on raster
#' @param loc_x data.frame Intersection of grid with study domain
#' @param mesh inla.mesh Spatial grid of observations
#' 
#' @return list A named list
#' 
#' @noRd
fm_shape_vms_logbook_data_st <- function(
    vmslogbook_data_0,
    time.step_df,
    grid_projection,
    gridpolygon_sf,
    loc_x,
    mesh
    ) {
  
  ## Join commercial data with time dataframe
  vmslogbook_data_1 <- vmslogbook_data_0 %>%
    inner_join(time.step_df)
  
  ## Convert commercial data into sf object to intersect with gridpolygon
  vmslogbook_data_sf <- st_as_sf(vmslogbook_data_1,
                                 coords = c("long","lati"),
                                 crs = grid_projection)
  
  ## Intersect 'VMS x logbook' data with spatial domain
  vmslogbook_data_sf <- vmslogbook_data_sf[st_intersects(vmslogbook_data_sf,gridpolygon_sf) %>% lengths > 0,]
  vmslogbook_data_2 <- st_join(vmslogbook_data_sf,gridpolygon_sf) %>%
    mutate(long = st_coordinates(.)[,1],
           lati = st_coordinates(.)[,2]) %>%
    as.data.frame() %>%
    dplyr::select(-geometry)
  
  # CPUE data
  y_com_i <- vmslogbook_data_2$CPUE_spp
  
  # time step
  t_com_i <- vmslogbook_data_2$t
  
  # clusters
  b_com_i <- vmslogbook_data_2$f
  
  # Number of fishing points per cell
  c_com_x <- array(NA,
                   dim = c(nrow(loc_x),
                           nrow(time.step_df),
                           length(unique(vmslogbook_data_2$f))))
  
  for(f_i in 1:length(unique(vmslogbook_data_2$f))){
  
    for(t_i in 1:length(unique(vmslogbook_data_2$t))){
  
      df_c_com_x <- vmslogbook_data_2 %>%
        filter(f == f_i & t == t_i) %>%
        dplyr::select("layer","t") %>%
        group_by(layer,t) %>%
        count() %>%
        arrange(t) %>%
        pivot_wider(id_cols = c("layer"), names_from = "t",values_from = "n") %>%
        full_join(loc_x[,c("layer","cell")],by = "layer") %>%
        inner_join(loc_x[,c("layer","cell")]) %>%
        arrange(cell) %>%
        ungroup() %>%
        dplyr::select(-cell,-layer)
      c_com_x[,t_i,f_i] <- as.matrix(df_c_com_x)
  
    }
  
  }
  
  c_com_x[is.na(c_com_x)] <- 0
  
  ## Mesh objects for commercial data
  A <- inla.spde.make.A(mesh, loc=as.matrix(vmslogbook_data_2[,c("long","lati")] ))
  A <- as( A, "dgTMatrix" )
  Aix_ij_com <- cbind(A@i,A@j)
  Aix_w_com <- A@x
  
  # Return named list as output
  return(
    list(
      "b_com_i" = b_com_i,
      "y_com_i" = y_com_i,
      "c_com_x" = c_com_x,
      "t_com_i" = t_com_i,
      "Aix_ij_com" = Aix_ij_com,
      "Aix_w_com" = Aix_w_com,
      "vmslogbook_data_2" = vmslogbook_data_2
    )
  )
}
```
  
```{r example-fm_shape_vms_logbook_data_st, eval = FALSE}
#' \dontrun{
# fm_shape_vms_logbook_data_st(
#     vmslogbook_data_0 = vmslogbook_data_0,
#     time.step_df = time.step_df,
#     grid_projection = grid_projection,
#     gridpolygon_sf = gridpolygon_sf,
#     loc_x = loc_x,
#     mesh = mesh
# )
#' }
```
  
```{r tests-fm_shape_vms_logbook_data_st}
test_that("fm_shape_vms_logbook_data_st works", {

  ## prepare inputs
  # vms data - unfiltered
  vmslogbook_data_file <- system.file("original_data",
                                      "Solea_solea",
                                      "vmslogbook_data.Rdata",
                                      package = "FishMap"
  )
  load(vmslogbook_data_file)
  
  # filter vms data as done in `fm_load_data()`
  fleet <- c("OTB_DEF_>=70_0","OTB_CEP_>=70_0","OTT_DEF_>=70_0")
  select_aggreg_level <- paste(fleet,collapse = "|")
  vmslogbook_data <- vmslogbook_data %>%
    filter(str_detect(LE_MET_level6,select_aggreg_level))
  vmslogbook_data$LE_MET_level6 <- factor(as.character(vmslogbook_data$LE_MET_level6),levels = fleet)
  vmslogbook_data_0 <- vmslogbook_data %>% ungroup %>% dplyr::select(-layer)
  
  # study domain
  study_domain_file <- system.file("original_data",
                                   "Solea_solea",
                                   "study_domain.Rdata",
                                   package = "FishMap"
  )
  load(study_domain_file)

  # mesh grid
  grid_limit <- raster::extent(c(-6, 0, 42, 48))
  
  # `fm_build_domain_mesh_spde()` call
  domain_mesh_spde_outputs <- fm_build_domain_mesh_spde(
    grid_limit = grid_limit,
    resol = 0.05,
    grid_projection = "+proj=longlat +datum=WGS84",
    study_domain = study_domain,
    create_mesh = "from_shapefile",
    k = 0.25,
    vmslogbook_data,
    study_domain_sf = NULL,
    Alpha = 2)
  
  # time df
  year_vec <- 2018:2018
  month_vec <- 11:11
  time.step_df <- expand.grid(month_vec,year_vec)
  colnames(time.step_df) <- c("Month","Year")
  time.step_df <- time.step_df %>%
    arrange(Year,Month) %>%
    mutate(Month = ifelse(Month < 10,paste0("0",Month),Month)) %>%
    mutate(Year_Month = paste0(Year,"_",Month)) %>%
    mutate(t = 1:nrow(time.step_df))
  time.step_df$Year <- as.character(time.step_df$Year)
  time.step_df$Month <- as.character(time.step_df$Month)
    
  ## run function
  result <- fm_shape_vms_logbook_data_st(
    vmslogbook_data_0 = vmslogbook_data_0,
    time.step_df = time.step_df,
    grid_projection = "+proj=longlat +datum=WGS84",
    gridpolygon_sf = domain_mesh_spde_outputs[["gridpolygon_sf"]],
    loc_x = domain_mesh_spde_outputs[["loc_x"]],
    mesh = domain_mesh_spde_outputs[["mesh"]]
)
  
  ## test outputs
  #' @description Testing that fm_shape_sci_data_st returns a list
  expect_type(object = result,
              type = "list")
  
  #' @description Testing names of the list
  expect_named(object = result,
               expected = c("b_com_i",
                            "y_com_i",
                            "c_com_x",
                            "t_com_i",
                            "Aix_ij_com",
                            "Aix_w_com", 
                            "vmslogbook_data_2"
                            )
               )
  
  #' @description Testing types inside the list
  expect_type(result[["b_com_i"]], "double")
  expect_type(result[["y_com_i"]], "double")
  expect_type(result[["c_com_x"]], "double")
  expect_type(result[["t_com_i"]], "integer")
  expect_type(result[["Aix_ij_com"]], "integer")
  expect_type(result[["Aix_w_com"]], "double")
  expect_type(result[["vmslogbook_data_2"]], "list")

})
```


# `fm_load_data()` : prepare and load model inputs

This function prepares all the necessary output for the model fitting. It will filter and shape the observation data (VMS and scientific). It will generate the spatial mesh for the study domain. All outputs are reported as part of a named list.
    
```{r function-fm_load_data}
#' Load and prepare data for model fitting
#'
#' @param species character Species of interest
#' @param fleet character Fleet chosen according to the species of interest. A fleet is considered to have homogeneous catchability and targeting behavior.
#' @param fitted_data character Type of the data to be fitted to the model (either `biomass` for biomass data - positive-continuous data - or `presabs` for presence-absence data). Default is `biomass`
#' @param survey_data_file character File containing the scientific (survey) data
#' @param vmslogbook_data_file  character File containing the commercial (vmslogbook) data
#' @param study_domain_file  character File containing the data describing the study area
#' @param year_start integer Starting year
#' @param year_end integer Ending year
#' @param month_start integer Starting month
#' @param month_end integer Ending month
#' @param time_step character Time step for the model (either `Month` for monthly time step or `Quarter` for quarterly time step). Default is `Month`
#' @param k numeric Parameter controlling the number of knots of the mesh. The higher the denser.
#' @param grid_xmin,grid_xmax,grid_ymin,grid_ymax  numeric Limitation of the grid for the spatial domain
#' @param seed integer The seed controlling for random effect. Default is 29510.
#' 
#' @importFrom dplyr ungroup select filter arrange mutate
#' @importFrom stringr str_detect
#' @importFrom tictoc tic toc
#' @importFrom withr local_seed
#' 
#' @return list A named list of all necessary outputs for model fitting (`fm_fit_model()`)
#' @export
#'
#' @examples
fm_load_data <- function(species,
                         fleet,
                         fitted_data = c("biomass","presabs"),
                         survey_data_file,
                         vmslogbook_data_file,
                         study_domain_file,
                         year_start,
                         year_end,
                         month_start,
                         month_end,
                         time_step = c("Month","Quarter"),
                         k,
                         grid_xmin,
                         grid_xmax,
                         grid_ymin,
                         grid_ymax,
                         seed = 29510
                         ) {
  ## Load data
  #-----------
  message("Running step 1 -loading data-")
  tic("Step 1 -loading data-")
  
  # set seed
  local_seed(seed = seed)
  
  script_folder <- system.file("original_scripts", package = "FishMap") 
  
  fitted_data <- match.arg(fitted_data)
  time_step <- match.arg(time_step)
  
  # Scientific data
  n_survey <- 1 # number of surveys
  load(survey_data_file)
  scientific_observation <- "CPUE" # 'CPUE' or 'Density'
  survey_data_0 <- survey_data %>% ungroup %>% dplyr::select(-layer)
  
  # 'VMS x logbook' data
  load(vmslogbook_data_file)
  
  select_aggreg_level <- paste(fleet,collapse = "|")
  vmslogbook_data <- vmslogbook_data %>%
    filter(str_detect(LE_MET_level6,select_aggreg_level))
  
  vmslogbook_data$LE_MET_level6 <- factor(as.character(vmslogbook_data$LE_MET_level6),levels = fleet)
  
  vmslogbook_data_0 <- vmslogbook_data %>% ungroup %>% dplyr::select(-layer)
  
  ## Time series
  #-------------
  year_vec <- year_start:year_end
  month_vec <- month_start:month_end

  if(time_step == "Month"){
  
    time.step_df <- expand.grid(month_vec,year_vec)
    colnames(time.step_df) <- c("Month","Year")
  
    time.step_df <- time.step_df %>%
      arrange(Year,Month) %>%
      mutate(Month = ifelse(Month < 10,paste0("0",Month),Month)) %>%
      mutate(Year_Month = paste0(Year,"_",Month)) %>%
      mutate(t = 1:nrow(time.step_df))
    time.step_df$Year <- as.character(time.step_df$Year)
    time.step_df$Month <- as.character(time.step_df$Month)
  
  }else if(time_step == "Quarter"){
  
    time.step_df <- expand.grid(1:4,all_years)
    colnames(time.step_df) <- c("Quarter","Year")
  
    time.step_df <- time.step_df %>%
      arrange(Year,Quarter) %>%
      mutate(Quarter = ifelse(Quarter < 10,paste0("0",Quarter),Quarter)) %>%
      mutate(Year_Quarter = paste0(Year,"_",Quarter)) %>%
      mutate(t = 1:nrow(time.step_df))
    time.step_df$Year <- as.character(time.step_df$Year)
    time.step_df$Quarter <- as.character(time.step_df$Quarter)
  
  }
  
  
  ## Configure spatial domain
  #--------------------------
  grid_xmin <- grid_xmin
  grid_xmax <- grid_xmax
  grid_ymin <- grid_ymin
  grid_ymax <- grid_ymax
  
  grid_limit <- raster::extent(
    c(grid_xmin,
      grid_xmax,
      grid_ymin,
      grid_ymax)
  )
  
  grid_projection <- "+proj=longlat +datum=WGS84"
  
  resol <- 0.05 # resolution of the discretization grid
  create_mesh <- "from_shapefile"
  # from_shapefile: the mesh will be more regular on the grid
  # from_data: the mesh will be denser in the areas where there are data
  
  # Mesh parameterization
  # reduce the mesh size (k = 0.25 now) reduces the number of knots at which the spatial random effect is computed.
  k <- k
  Alpha <- 2
  
  load(study_domain_file)
  
  ## Load domain / mesh / spde object
  domain_mesh_spde_outputs <- fm_build_domain_mesh_spde(
    grid_limit = grid_limit,
    resol = resol,
    grid_projection = grid_projection,
    study_domain = study_domain,
    create_mesh = create_mesh,
    k = k,
    vmslogbook_data = vmslogbook_data,
    study_domain_sf = study_domain_sf,
    Alpha = Alpha
  )
  
  ## Shape scientific data
  sci_data_st_outputs <- fm_shape_sci_data_st(
    survey_data_0 = survey_data_0,
    time.step_df = time.step_df,
    grid_projection = grid_projection,
    gridpolygon_sf = domain_mesh_spde_outputs[["gridpolygon_sf"]],
    scientific_observation = scientific_observation,
    Sci.obs_spp = Sci.obs_spp,
    mesh = domain_mesh_spde_outputs[["mesh"]]
    )
  
  ## Shape commercial data
  vms_logbook_data_st_outputs <- fm_shape_vms_logbook_data_st(
    vmslogbook_data_0 = vmslogbook_data_0,
    time.step_df = time.step_df,
    grid_projection = grid_projection,
    gridpolygon_sf = domain_mesh_spde_outputs[["gridpolygon_sf"]],
    loc_x = domain_mesh_spde_outputs[["loc_x"]],
    mesh = domain_mesh_spde_outputs[["mesh"]]
  )
  
  if(fitted_data=="presabs"){
    y_com_i[which(y_com_i > 0)] <- 1
    y_sci_i[which(y_sci_i > 0)] <- 1
    lf_link <- 1 # logit link
  }
  
  
  ## Covariates
  #------------
  # load(file.path(data_folder,"bathy_pred.Rdata"))
  bathy_pred = rep(0,nrow(domain_mesh_spde_outputs[["loc_x"]]))
  cov_x_pred <- matrix(data = bathy_pred, ncol = 1)
  
  # load(file.path(data_folder,"bathy_com.Rdata"))
  bathy_com = rep(0,nrow(vms_logbook_data_st_outputs[["vmslogbook_data_2"]]))
  cov_x_com <- matrix(data = bathy_com, ncol = 1)
  
  # load(file.path(data_folder,"bathy_sci.Rdata"))
  bathy_sci = rep(0,nrow(sci_data_st_outputs[["survey_data_2"]]))
  cov_x_sci <- matrix(data = bathy_sci, ncol = 1)

  # finished step 1 -loading data-
  toc()

  # return outputs as named list
  return(list("species" = species,
              "b_com_i" = vms_logbook_data_st_outputs[["b_com_i"]],
              "mesh" = domain_mesh_spde_outputs[["mesh"]],
              "time.step_df" = time.step_df,
              "loc_x" = domain_mesh_spde_outputs[["loc_x"]],
              "y_com_i" = vms_logbook_data_st_outputs[["y_com_i"]],
              "y_sci_i" = sci_data_st_outputs[["y_sci_i"]],
              "cov_x_com" = cov_x_com,
              "cov_x_sci" = cov_x_sci,
              "c_com_x" = vms_logbook_data_st_outputs[["c_com_x"]],
              "t_com_i" = vms_logbook_data_st_outputs[["t_com_i"]],
              "t_sci_i" = sci_data_st_outputs[["t_sci_i"]],
              "spde" = domain_mesh_spde_outputs[["spde"]],
              "Aix_ij_com" = vms_logbook_data_st_outputs[["Aix_ij_com"]],
              "Aix_w_com" = vms_logbook_data_st_outputs[["Aix_w_com"]],
              "Aix_ij_sci" = sci_data_st_outputs[["Aix_ij_sci"]],
              "Aix_w_sci" = sci_data_st_outputs[["Aix_w_sci"]],
              "cov_x_pred" = cov_x_pred,
              "Aix_ij_pred" = domain_mesh_spde_outputs[["Aix_ij_pred"]],
              "Aix_w_pred" = domain_mesh_spde_outputs[["Aix_w_pred"]],
              "W" = domain_mesh_spde_outputs[["W"]],
              "n_survey" = n_survey,
              "MeshList_aniso" = domain_mesh_spde_outputs[["MeshList_aniso"]]
              )
         )
}
```
  
```{r examples-fm_load_data, eval = FALSE}
#' \donttest{
# run part1
survey_data_file <- system.file("original_data",
                                "Solea_solea",
                                "survey_data.Rdata",
                                package = "FishMap"
                                )

vmslogbook_data_file <- system.file("original_data",
                                "Solea_solea",
                                "vmslogbook_data.Rdata",
                                package = "FishMap"
                                )

study_domain_file <- system.file("original_data",
                                "Solea_solea",
                                "study_domain.Rdata",
                                package = "FishMap"
                                )

fm_data_inputs <- fm_load_data(species = "Solea_solea",
                         fleet = c("OTB_DEF_>=70_0","OTB_CEP_>=70_0","OTT_DEF_>=70_0"),
                         fitted_data = "biomass",
                         survey_data_file = survey_data_file,
                         vmslogbook_data_file = vmslogbook_data_file,
                         study_domain_file = study_domain_file,
                         year_start = 2018,
                         year_end = 2018,
                         month_start = 11,
                         month_end = 11,
                         time_step = "Month",
                         k = 0.25,
                         grid_xmin = -6,
                         grid_xmax = 0,
                         grid_ymin = 42,
                         grid_ymax = 48)
#' }
```
  
```{r tests-fm_load_data}
test_that("fm_load_data works", {

  # You can test your model for small datas or big datas. You must run the tests locally with FISHMAP_UPDATE_OUTPUTS env at TRUE to store the rds file.
  
  test_resolution <- Sys.getenv("FISHMAP_TEST_RESOLUTION", unset = "small")
  
  if(test_resolution == "small"){
    k = 0.25
    month_start = 11
    month_end = 11
  }else if (test_resolution == "big") {
    k = 0.75
    month_start = 10
    month_end = 12
  }
  
  # Check `fm_load_data` input values
  
  #' @description Testing the inputs of `fm_load_data` are correct
  expect_error(object = fm_load_data(fitted_data = "notagoodinput"),
               regexp = "'arg' should be one of .biomass., .presabs.")
  expect_error(object = fm_load_data(time_step = "notagoodinput"),
               regexp = "'arg' should be one of .Month., .Quarter.")
  
  # run part1
  survey_data_file <- system.file("original_data",
                                  "Solea_solea",
                                  "survey_data.Rdata",
                                  package = "FishMap"
  )
  
  vmslogbook_data_file <- system.file("original_data",
                                      "Solea_solea",
                                      "vmslogbook_data.Rdata",
                                      package = "FishMap"
  )
  
  study_domain_file <- system.file("original_data",
                                   "Solea_solea",
                                   "study_domain.Rdata",
                                   package = "FishMap"
  )
  
  fm_data_inputs <- fm_load_data(species = "Solea_solea",
                                 fleet = c("OTB_DEF_>=70_0","OTB_CEP_>=70_0","OTT_DEF_>=70_0"),
                                 fitted_data = "biomass",
                                 survey_data_file = survey_data_file,
                                 vmslogbook_data_file = vmslogbook_data_file,
                                 study_domain_file = study_domain_file,
                                 year_start = 2018,
                                 year_end = 2018,
                                 month_start = month_start,
                                 month_end = month_end,
                                 time_step = "Month",
                                 k = k,
                                 grid_xmin = -6,
                                 grid_xmax = 0,
                                 grid_ymin = 42,
                                 grid_ymax = 48)
  
  
  # Update expected outputs here
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    # save output depending if we are in flat or in test
    output_inst_dir <- here::here("inst", "examples") 
    
    if (test_resolution == "small") {
      readr::write_rds(x = fm_data_inputs,
                       file = file.path(output_inst_dir, paste0("part1_output_", test_resolution , ".rds")))
    }else if (test_resolution == "big") {
      ## TODO what we need to check
    }
  }
  
  # check output is saved as rds
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    
    output_inst_dir <- here::here("inst", "examples")
    
    #' @description Test to check if we can save output
    expect_true(file.exists(file.path(output_inst_dir, paste0("part1_output_", test_resolution , ".rds"))))
  }
  
  # Check `fm_load_data` output values
  
  #' @description Testing the result of `fm_load_data` is a list
  expect_type(object = fm_data_inputs,  "list")
  
  #' @description Testing names of the list return by `fm_load_data`
  expect_named(
    object = fm_data_inputs,
    expected = c(
      "species",
      "b_com_i",
      "mesh",
      "time.step_df",
      "loc_x",
      "y_com_i",
      "y_sci_i",
      "cov_x_com",
      "cov_x_sci",
      "c_com_x",
      "t_com_i",
      "t_sci_i",
      "spde",
      "Aix_ij_com",
      "Aix_w_com",
      "Aix_ij_sci",
      "Aix_w_sci",
      "cov_x_pred",
      "Aix_ij_pred",
      "Aix_w_pred",
      "W",
      "n_survey",
      "MeshList_aniso"
    )
  )
  
  #' @description Testing types inside the list returned by `fm_load_data`
  expect_type(fm_data_inputs[["species"]], "character")
  expect_type(fm_data_inputs[["b_com_i"]], "double")
  expect_s3_class(fm_data_inputs[["mesh"]], "inla.mesh")
  expect_s3_class(fm_data_inputs[["time.step_df"]], "data.frame")
  expect_s3_class(fm_data_inputs[["loc_x"]], "data.frame")
  expect_type(fm_data_inputs[["y_com_i"]], "double")
  expect_type(fm_data_inputs[["y_sci_i"]], "double")
  expect_true(is.matrix(fm_data_inputs[["cov_x_com"]]))
  expect_true(is.matrix(fm_data_inputs[["cov_x_sci"]]))
  expect_true(is.array(fm_data_inputs[["c_com_x"]]))
  expect_type(fm_data_inputs[["t_com_i"]], "integer")
  expect_type(fm_data_inputs[["t_sci_i"]], "integer")
  expect_type(fm_data_inputs[["spde"]], "list")
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_com"]]))
  expect_type(fm_data_inputs[["Aix_w_com"]], "double")
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_sci"]]))
  expect_type(fm_data_inputs[["Aix_w_sci"]], "double")
  expect_true(is.matrix(fm_data_inputs[["cov_x_pred"]]))
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_pred"]]))
  expect_type(fm_data_inputs[["Aix_w_pred"]], "double")
  expect_type(fm_data_inputs[["W"]], "double")
  expect_type(fm_data_inputs[["n_survey"]], "double")
  expect_type(fm_data_inputs[["MeshList_aniso"]], "list")
  
  # retrieve tmp name of mesh dir, which changes for each execution
  mesh_dir <- dirname(path = fm_data_inputs$mesh$meta$prefix)
  mesh_aniso_dir <- dirname(path = fm_data_inputs$MeshList_aniso$anisotropic_spde$mesh$meta$prefix)
  
  #' @description Testing that tmpdir of the mesh exists
  expect_true(dir.exists(mesh_dir))
  expect_true(dir.exists(mesh_aniso_dir))
  
  # Testing for small model
  if(test_resolution == "small"){
    
    expected_outputs <- readr::read_rds(
      system.file(
        "examples",
        paste0("part1_output_", test_resolution , ".rds"),
        package = "FishMap")
    )
    
    # homogenize tmp dir value tested in above test
    expected_outputs$mesh$meta$prefix <-
      fm_data_inputs$mesh$meta$prefix
    expected_outputs$MeshList_aniso$anisotropic_spde$mesh$meta$prefix <-
      fm_data_inputs$MeshList_aniso$anisotropic_spde$mesh$meta$prefix
    
    # sort list and data frame elements to avoid order discrepancies
    resort_all <- function(x) {
      x <- x[sort(names(x))]
      
      result <- lapply(x, function(x) {
        if (inherits(x, c("data.frame", 'list'))) {
          x[sort(names(x))]
        } else{
          x
        }
      })
      
      result
    }
    resorted_result <- resort_all(fm_data_inputs)
    resorted_expected <- resort_all(expected_outputs)
    
    # remove name attributes (likely generated by a specific version of {sf})
    attr(resorted_result$loc_x$long, which = "names") <- NULL
    attr(resorted_result$loc_x$lati, which = "names") <- NULL
    attr(resorted_expected$loc_x$long, which = "names") <- NULL
    attr(resorted_expected$loc_x$lati, which = "names") <- NULL
    
    #' @description Testing that the result of `fm_load_data` is stable
    expect_equal(object = resorted_result,
                 expected = resorted_expected)
  }
  
})
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_fm_load_data.Rmd", check = FALSE,
               vignette_name = "Dev - Load Data")
# To perform check, please go to `dev/0_dev_history.Rmd` and run the section `Use everytime needed`
```

