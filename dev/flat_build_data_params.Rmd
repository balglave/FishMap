---
title: "flat_additional.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# fm_build_data_params_map

```{r function-fm_build_data_params_map}
#' function to build data
#'
#' @inheritParams fm_fit_model 
#' @param b_com_i b_com_i
#' @param mesh mesh
#' @param time.step_df time.step_df
#' @param loc_x loc_x
#' @param y_com_i y_com_i
#' @param y_sci_i y_sci_i
#' @param cov_x_com cov_x_com
#' @param cov_x_sci cov_x_sci
#' @param xfb_x   xfb_x
#' @param c_com_x c_com_x
#' @param t_com_i t_com_i
#' @param weights_com weights_com
#' @param t_sci_i t_sci_i
#' @param spde spde
#' @param Aix_ij_com Aix_ij_com
#' @param Aix_w_com Aix_w_com
#' @param Aix_ij_sci Aix_ij_sci
#' @param Aix_w_sci Aix_w_sci 
#' @param cov_x_pred cov_x_pred 
#' @param Aix_ij_pred Aix_ij_pred 
#' @param Aix_w_pred Aix_w_pred 
#' @param W W 
#' @param n_survey n_survey 
#' @param MeshList_aniso MeshList_aniso 
#' @param Version Version
#' 
#' @importFrom INLA inla.as.dgTMatrix
#' @importFrom stringr str_detect
#'
#' @return list
#'
fm_build_data_params_map <- function(SE, data_source, data_obs, samp_process, b_constraint, cov_samp_process, const_spphab, biomass_temporal, sampling_temporal, anisotropy, lf_link, b_com_i, mesh, time.step_df, loc_x, y_com_i, y_sci_i, cov_x_com, cov_x_sci, xfb_x, c_com_x, t_com_i, weights_com, t_sci_i, spde, Aix_ij_com, Aix_w_com, Aix_ij_sci, Aix_w_sci, cov_x_pred, Aix_ij_pred, Aix_w_pred, W, n_survey, MeshList_aniso, EM, ref_data, month_ref, Version) {
  options_vec = c('SE'=SE, # run ADREPORT
                  'data_source' = data_source, # 1: integrated, 2: scientific, 3: commercial
                  'data_obs' = data_obs,  # 1 : zinfgamma, 2 : zinflognormal
                  'samp_process' = samp_process, # 1: sampling process is activated, else : it is ignored
                  'b_constraint' = b_constraint, # 1 : b > 0 | 2 : b is free
                  'cov_samp_process' = cov_samp_process, # 0: no covariate in the sampling process, 1: covariate in the samplign process
                  'const_spphab' = const_spphab, # 1: constant species-habitat relationship in time
                  'biomass_temporal' = biomass_temporal, # Type of temporal correlation in biomass field - 0: none, 1: AR1
                  'sampling_temporal' = sampling_temporal, # Type of temporal correlation in sampling process - 0: none, 1: AR1
                  'anisotropy' = anisotropy, # 0: no anisotropy, 1: anisotropy
                  'lf_link' = lf_link # latent field link function. 0: log link, 1: logit link
  )
  
  n_com.fleets = length(unique(b_com_i)) # number of fleets
  
  # Init values on random effect
  deltainput_x = matrix(0,nrow = mesh$n, ncol = length(time.step_df$t)) # when SPDE approach
  etainput_x = array(0,c(mesh$n,length(time.step_df$t),n_com.fleets))
  
  ## Data & Params
  Map = list()
  Random = c()
  if(data_source == 1){   # Integrated model (scientific_commercial)
    
    Data = list( "options_vec"=options_vec,
                 
                 "n_x" = mesh$n, # number of nodes in the mesh
                 "n_t" = nrow(time.step_df), # number of time steps
                 "n_p" = nrow(loc_x), # number of cells in the prediction grid
                 "n_com_i" = length(y_com_i), # number of commercial samples
                 "n_sci_i" = length(y_sci_i), # number of scientific samples
                 "n_eta" = n_com.fleets, # number of vessels
                 "n_S" = 1+n_com.fleets, # number of range and marginal variance parameters
                 
                 "cov_x_com"=cov_x_com, # covariate of the biomass field
                 "cov_x_sci"=cov_x_sci,
                 
                 "cov_fb"=if(is.null(xfb_x)){as.matrix(rep(1,nrow(cov_x_com)))}else{xfb_x}, # covariate for the commercial sampling equation
                 
                 "c_com_x"=c_com_x, # matrix of fleet counts at each time step in each cells
                 "y_com_i"=y_com_i, # commercial CPUE
                 "b_com_i" = (as.numeric(b_com_i)-1), # fleet index
                 "t_com_i" = t_com_i-1, # time step for ith observation of the commercial data
                 "q2_com" = rep(1,length(unique(b_com_i))), # commercial catchability
                 "weights_com" = weights_com, # weighting factor for commercial data
                 
                 "y_sci_i"=y_sci_i, # scientific CPUE
                 "t_sci_i" = t_sci_i-1, # time step for ith observation of the scientific data
                 "q2_sci" =  1,  # scientific catchability
                 
                 "spde"=spde, # SPDE objects
                 "spde_aniso" =list(),
                 "M0"=spde$M0,
                 "M1"=spde$M1,
                 "M2"=spde$M2,
                 
                 "Aix_ij_com"=Aix_ij_com,
                 "Aix_w_com"=Aix_w_com,
                 
                 "Aix_ij_sci"=Aix_ij_sci,
                 "Aix_w_sci"=Aix_w_sci,
                 
                 "cov_fb_mesh"=if(is.null(xfb_x)){as.matrix(rep(1,mesh$n))}else{xfb_x},
                 
                 "cov_x_pred"=cov_x_pred,
                 "cov_fb_pred"=if(is.null(xfb_x)){as.matrix(rep(1,nrow(cov_x_pred)))}else{xfb_x},
                 "Aix_ij_pred"=Aix_ij_pred,
                 "Aix_w_pred"=Aix_w_pred,
                 "W"=W
    )
    
    Params = list("beta_j0"=0,
                  "beta_j0season"=rep(0,nrow(time.step_df)),
                  "beta_j0year"=rep(0,nrow(time.step_df)),
                  "beta_j"=array(0,c(nrow(time.step_df),ncol(Data$cov_x_com))), # linear predictor for abundance
                  "beta_fb0"=rep(0,n_com.fleets),
                  "beta_fb0season"=matrix(0,nrow = nrow(time.step_df),ncol = n_com.fleets),
                  "beta_fb0year"=matrix(0,nrow = nrow(time.step_df),ncol = n_com.fleets),
                  "beta_fb"=matrix(0,nrow = ncol(Data$cov_fb), ncol = n_com.fleets), # additionnal linear predictor for sampling intensity
                  "par_b"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_bseason"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_byear"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_bseasonyear"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "logta_S"=rep(0,1+n_com.fleets), # parameters of SPDE object (see below)
                  "logtaAR1_S"=rep(0,1+n_com.fleets), # parameters of SPDE object (see below)
                  "logkappa_S"=rep(0,1+n_com.fleets),
                  "deltainput_x"=deltainput_x, # input for random noise
                  "epsiloninput_x"=deltainput_x,
                  "etainput_x"=etainput_x,
                  "psiinput_x"=etainput_x,
                  "logSigma_com"=rep(0,n_com.fleets),
                  "logSigma_sci"=log(1),
                  
                  "q1_com"=rep(0,n_com.fleets),
                  "q1_sci"=rep(0,n_survey),
                  
                  "k_com" = rep(1,c(n_com.fleets)),
                  "k_sci" = 1,
                  
                  "rho_epsilon" = 0,
                  "rho_psi" = 0,
                  "ln_Hdelta_input" = rep(0, 2),
                  "ln_Heta_input" = rep(0, 2)
    )
    
    
    
  }else if(data_source == 2){ # scientific model (scientific_only)
    
    Data = list( "options_vec"=options_vec,
                 
                 "n_x" = mesh$n, # number of cells
                 "n_t" = nrow(time.step_df), # number of time steps
                 "n_p" = nrow(loc_x),
                 "n_sci_i" = length(y_sci_i), # number of scientific samples
                 "n_eta" = n_com.fleets,
                 "n_S" = 1, # number of range and marginal variance parameters
                 
                 # covariate of the biomass field
                 "cov_x_sci"=cov_x_sci,
                 
                 "y_sci_i"=y_sci_i, # scientific CPUE
                 "t_sci_i" = (t_sci_i-1), # time step for ith observation of the scientific data
                 "q2_sci" =  1,  # scientific catchability
                 
                 "spde"=spde, # SPDE objects
                 "spde_aniso" =list(),
                 "M0"=spde$M0,
                 "M1"=spde$M1,
                 "M2"=spde$M2,
                 
                 "Aix_ij_sci"=Aix_ij_sci,
                 "Aix_w_sci"=Aix_w_sci,
                 
                 "cov_x_pred"=cov_x_pred,
                 "Aix_ij_pred"=Aix_ij_pred,
                 "Aix_w_pred"=Aix_w_pred,
                 "W"=W
    )
    
    Params = list("beta_j0"=0,
                  "beta_j0season"=rep(0,nrow(time.step_df)),
                  "beta_j0year"=rep(0,nrow(time.step_df)),
                  
                  "beta_j"=array(0,c(nrow(time.step_df),ncol(Data$cov_x_com))), # linear predictor for abundance
                  
                  "logta_S"=rep(0,1), # parameters of SPDE object (see below)
                  "logtaAR1_S"=rep(0,1), # parameters of SPDE object (see below)
                  
                  "logkappa_S"=rep(0,1),
                  "deltainput_x"=deltainput_x, # input for random noise
                  "epsiloninput_x"=deltainput_x,
                  
                  "logSigma_sci"=log(1),
                  
                  "q1_sci"=rep(0,n_survey),
                  
                  "k_sci" = 1,
                  
                  "rho_epsilon" = 0,
                  "ln_Hdelta_input" = rep(0, 2)
    )
    
    Map[["k_sci"]] <- factor(NA)
    
    
  }else if(data_source == 3){ # commercial model (commercial_only)
    
    Data = list( "options_vec"=options_vec,
                 
                 "n_x" = mesh$n, # number of cells
                 "n_t" = nrow(time.step_df), # number of time steps
                 "n_p" = nrow(loc_x),
                 "n_com_i" = length(y_com_i), # number of commercial samples
                 "n_eta" = n_com.fleets, # number of vessels
                 "n_S" = 1+n_com.fleets, # number of range and marginal variance parameters
                 
                 "cov_x_com"=cov_x_com, # covariate of the biomass field
                 "cov_fb"=if(is.null(xfb_x)){as.matrix(rep(1,nrow(cov_x_com)))}else{xfb_x}, # covariate for the commercial sampling equation
                 
                 "c_com_x"=c_com_x, # matrix of fleet counts at each time step in each cells
                 "y_com_i"=y_com_i, # commercial CPUE
                 "b_com_i" = (as.numeric(b_com_i)-1), # fleet index
                 "t_com_i" = (t_com_i-1), # time step for ith observation of the commercial data
                 "q2_com" = rep(1,length(unique(b_com_i))), # commercial catchability
                 "weights_com" = 1, # weighting factor for commercial data
                 
                 "spde"=spde, # SPDE objects
                 "spde_aniso" =list(),
                 "M0"=spde$M0,
                 "M1"=spde$M1,
                 "M2"=spde$M2,
                 
                 "Aix_ij_com"=Aix_ij_com,
                 "Aix_w_com"=Aix_w_com,
                 
                 "cov_fb_mesh"=if(is.null(xfb_x)){as.matrix(rep(1,mesh$n))}else{xfb_x},
                 
                 "cov_x_pred"=cov_x_pred,
                 "cov_fb_pred"=if(is.null(xfb_x)){as.matrix(rep(1,nrow(cov_x_pred)))}else{xfb_x},
                 "Aix_ij_pred"=Aix_ij_pred,
                 "Aix_w_pred"=Aix_w_pred,
                 "W"=W
    )
    
    Params = list("beta_j0"=0,
                  "beta_j0season"=rep(0,nrow(time.step_df)),
                  "beta_j0year"=rep(0,nrow(time.step_df)),
                  "beta_j"=array(0,c(nrow(time.step_df),ncol(Data$cov_x_com))), # linear predictor for abundance
                  "beta_fb0"=rep(0,n_com.fleets),
                  "beta_fb0season"=matrix(0,nrow = nrow(time.step_df),ncol = n_com.fleets),
                  "beta_fb0year"=matrix(0,nrow = nrow(time.step_df),ncol = n_com.fleets),
                  "beta_fb"=matrix(0,nrow = ncol(Data$cov_fb), ncol = n_com.fleets), # additionnal linear predictor for sampling intensity
                  "par_b"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_bseason"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_byear"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_bseasonyear"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "logta_S"=rep(0,1+n_com.fleets), # parameters of SPDE object (see below)
                  "logtaAR1_S"=rep(0,1+n_com.fleets), # parameters of SPDE object (see below)
                  "logkappa_S"=rep(0,1+n_com.fleets),
                  "deltainput_x"=deltainput_x,
                  "epsiloninput_x"=deltainput_x,
                  "etainput_x"=etainput_x,
                  "psiinput_x"=etainput_x,
                  "logSigma_com"=rep(0,n_com.fleets),
                  "q1_com"=rep(0,n_com.fleets),
                  "k_com" = rep(1,c(n_com.fleets)),
                  "rho_epsilon" = 0,
                  "rho_psi" = 0,
                  "ln_Hdelta_input" = rep(0, 2),
                  "ln_Heta_input" = rep(0, 2)
    )
    
  }
  
  ## Random effect of the latent field
  if(biomass_temporal == 1){
    
    Map[["deltainput_x"]] <- factor(rep(NA,length(deltainput_x)))
    Random <- c(Random,"epsiloninput_x")
    Map[["logtaAR1_S"]] <- c(1) # carefull : Map of 'biomass_temporal' must be before 'sampling_temporal'
    Map[["logta_S"]] <- c(NA)
    
  }else{
    
    Map[["rho_epsilon"]] <- factor(NA)
    Map[["epsiloninput_x"]] <- factor(rep(NA,length(deltainput_x)))
    Random <- c(Random,"deltainput_x")
    Map[["logtaAR1_S"]] <- c(NA)
    Map[["logta_S"]] <- c(1) # carefull : Map of 'biomass_temporal' must be before 'sampling_temporal'
    
  }
  
  if( "spde_aniso" %in% names(Data) ) Data[['spde_aniso']] = list("n_s"=MeshList_aniso$anisotropic_spde$n.spde, "n_tri"=nrow(MeshList_aniso$anisotropic_spde$mesh$graph$tv), "Tri_Area"=MeshList_aniso$Tri_Area, "E0"=MeshList_aniso$E0, "E1"=MeshList_aniso$E1, "E2"=MeshList_aniso$E2, "TV"=MeshList_aniso$TV-1, "G0"=MeshList_aniso$anisotropic_spde$param.inla$M0, "G0_inv"=inla.as.dgTMatrix(solve(MeshList_aniso$anisotropic_spde$param.inla$M0)) )
  if(anisotropy == F) Map[["ln_Hdelta_input"]] <- factor(rep(NA, 2))
  
  # constant species habitat relationship
  Params[["beta_j"]] = matrix(rep(0,ncol(cov_x_com)),nrow=1)
  Map[["beta_j"]] = factor(matrix(rep(NA,ncol(cov_x_com)),nrow=nrow(Params[["beta_j"]])))
  
  ## Map and Random which are common to model 1 and 3 (integrated and commercial models)
  if(data_source %in% c(1,3)){
    
    # constant kappa
    Map[["logkappa_S"]] <- c(0,rep(1,n_com.fleets))
    
    ## Targeting
    Map[["par_bseason"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
    Map[["par_byear"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
    Map[["par_bseasonyear"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
    
    ## Covariates effects
    if(is.null(xfb_x) & samp_process==1){
      Map[["beta_fb"]]=factor(matrix(NA,nrow = ncol(Data$cov_fb), ncol = n_com.fleets)) # additionnal linear predictor for sampling intensity
    }
    
    
    ## Eliminate linkeage of density and sampling intensity
    if( EM=="fix_b" ){
      
      Map[["par_b"]] = factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
      Map[["par_bseason"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
      Map[["par_byear"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
      
    }
    
    ## Auto-regressive process
    if(sampling_temporal == 1){
      
      Map[["etainput_x"]] <- factor(array(NA,c(nrow(etainput_x),ncol(etainput_x),n_com.fleets)))
      Random <- c(Random,"etainput_x","psiinput_x")
      Map[["logta_S"]] <- c(Map[["logta_S"]],rep(NA,(length(Params$logta_S)-1)))
      Map[["logtaAR1_S"]] <- c(Map[["logtaAR1_S"]],seq(1:(length(Params$logta_S)-1)))
      
    }else{
      
      Map[["rho_psi"]] <- factor(NA)
      Map[["psiinput_x"]] <- factor(array(NA,c(nrow(etainput_x),ncol(etainput_x),n_com.fleets)))
      Random <- c(Random,"etainput_x")
      Map[["logta_S"]] <- c(Map[["logta_S"]],seq(1:(length(Params$logta_S)-1)))
      Map[["logtaAR1_S"]] <- c(Map[["logtaAR1_S"]],rep(NA,(length(Params$logta_S)-1)))
      
    }
    
    ## Anisotropy
    if(anisotropy == 0) Map[["ln_Heta_input"]] <- factor(rep(NA, 2))
    
    ## No sampling process
    if(samp_process == 0){
      
      Params[["etainput_x"]] = NULL
      Params[["psiinput_x"]] = NULL
      Params[["beta_fb"]] = NULL
      Params[["beta_fb0"]] = NULL
      Params[["beta_fb0year"]] = NULL
      Params[["beta_fb0season"]] = NULL
      Params[["par_b"]] = NULL
      Params[["par_byear"]] = NULL
      Params[["par_bseason"]] = NULL
      Params[["par_bseasonyear"]] = NULL
      Params[["par_bseasonyear"]] = NULL
      Params[["rho_psi"]] = NULL
      Params[["ln_Heta_input"]] = NULL
      
      if(T %in% str_detect(Random,"etainput_x")) Random = Random[-which(Random == "etainput_x")]
      if(T %in% str_detect(Random,"psiinput_x")) Random = Random[-which(Random == "psiinput_x")]
      if(T %in% str_detect(Random,"par_b")) Random = Random[-which(Random == "par_b")]
      
      Map[["logta_S"]][2:(n_com.fleets+1)]=NA
      Map[["logtaAR1_S"]][2:(n_com.fleets+1)]=rep(NA,n_com.fleets)
      Map[["logkappa_S"]][2:(n_com.fleets+1)]=rep(NA,n_com.fleets)
      Map[["beta_fb0"]]=NULL
      Map[["beta_fb0season"]]=NULL
      Map[["beta_fb0year"]]=NULL
      Map[["beta_fb"]]=NULL
      Map[["par_b"]]=NULL
      Map[["par_bseason"]]=NULL
      Map[["par_byear"]]=NULL
      Map[["par_bseasonyear"]]=NULL
      Map[["etainput_x"]] = NULL
      Map[["psiinput_x"]] = NULL
      Map[["rho_psi"]] = NULL
      Map[["rho_psi"]] = NULL
      Map[["ln_Heta_input"]] = NULL
      
    }
    
    ## Fix reference level of the first commercial fleet
    Map[["k_com"]] <- seq(1:(length(Params$k_com)))
    Map[["k_com"]][1] <- NA # reference level is the first fleet
    Map[["k_com"]] <- factor(Map[["k_com"]])
    
    if(samp_process == 1){
      
      Map[["beta_fb0"]] = factor(rep(NA,n_com.fleets))
      Map[["beta_fb0season"]] = matrix(NA,nrow = nrow(time.step_df),ncol = n_com.fleets)
      Map[["beta_fb0season"]] = factor(Map[["beta_fb0season"]])
      
    }
    
  }
  
  ## Set scientific data as reference data
  if(data_source == 1 & ref_data == "sci"){
    
    Map[["k_com"]] <- seq(1:(length(Params$k_com)))
    Map[["k_com"]] <- factor(Map[["k_com"]])
    
    Map[["k_sci"]] <- factor(NA)
    
  }
  
  ## Intercept of latent field is yearly and seasonnal
  Map[["beta_j0year"]] = as.numeric(time.step_df$Year) - (min(as.numeric(time.step_df$Year)-1))
  Map[["beta_j0year"]][which(Map[["beta_j0year"]] == 1)] = NA
  Map[["beta_j0year"]] = factor(Map[["beta_j0year"]])
  
  Map[["beta_j0season"]] = as.numeric(time.step_df[,1]) - (min(as.numeric(time.step_df[,1])-1))
  Map[["beta_j0season"]][which(Map[["beta_j0season"]] == month_ref)] = NA
  Map[["beta_j0season"]] = factor(Map[["beta_j0season"]])
  
  
  ## If scientific model
  if(data_source == 2){
    if(str_detect(Version,"com_x_sci_data")) Random = c("epsiloninput_x")
    
    if(nrow(time.step_df) == 1){
      
      Map[["beta_j0year"]] = factor(rep(NA,nrow(time.step_df)))
      Map[["beta_j0season"]] = factor(rep(NA,nrow(time.step_df)))
      Map[["ln_Hdelta_input"]] <- factor(rep(NA, 2))
      Map[["logkappa_S"]] <- NULL
      Map[["logta_S"]] <- factor(NA)
      Map[["k_sci"]] <- factor(NA)
      
    }
    
  }
  
  ## If only one time step, fix the auto-regressive parameter
  if(nrow(time.step_df) == 1) Map[["rho_epsilon"]] <- factor(NA)
  
  ## Map of logkappa_S, logta_S, logtaAR1_S
  if(data_source != 2) Map[["logkappa_S"]]=factor(Map[["logkappa_S"]])
  if(!is.null(Map[["logta_S"]])) Map[["logta_S"]]=factor(Map[["logta_S"]])
  if(!is.null(Map[["logtaAR1_S"]])) Map[["logtaAR1_S"]]=factor(Map[["logtaAR1_S"]])
  
  ## Presence-absence framework
  if(lf_link == 1){
    
    if(data_source %in% c(1,3)){
      Params$k_com <- rep(0,length(Params$k_com))
      Map$k_com <- NULL
      Map[["q1_com"]] <- factor(rep(NA,length(Params$q1_com)))
      Map[["logSigma_com"]] <- factor(rep(NA,length(Params$logSigma_com)))
    }
    
    if(data_source %in% c(1,2)){
      Params$k_sci <- rep(0,length(Params$k_sci))
      Map[["k_sci"]] <- factor(NA)
      Map[["q1_sci"]] <- factor(NA)
      Map[["logSigma_sci"]] <- factor(NA)
    }
    
    if(data_source %in% 3) Map$k_com <- factor(c(NA,1:(length(Params$k_com)-1)))
    
  }
  
  return(
    list(
      data = Data,
      map = Map,
      params = Params,
      random = Random
    )
  )
}

```

An example of the function but she is not exported. Only use to remove source inside the function `fm_fit_model`

```{r, eval=FALSE}
## Settings all params
  
  SE <- 1
  data_source <- 1
  data_obs <- 2
  samp_process <- 0
  b_constraint <- 2
  const_spphab <- 1
  cov_samp_process <- 0
  biomass_temporal <- 1
  sampling_temporal <- 0
  anisotropy <- 0
  lf_link <- 0
  ref_data <- "com"
  EM <- "est_b"
  month_ref <- 1
  compute_sd <- FALSE
  
  fm_data_inputs <- fm_load_data()
  
  species <- fm_data_inputs[["species"]]
  b_com_i <- fm_data_inputs[["b_com_i"]]
  mesh <- fm_data_inputs[["mesh"]]
  time.step_df <- fm_data_inputs[["time.step_df"]]
  loc_x <- fm_data_inputs[["loc_x"]]
  y_com_i <- fm_data_inputs[["y_com_i"]]
  y_sci_i <- fm_data_inputs[["y_sci_i"]]
  cov_x_com <- fm_data_inputs[["cov_x_com"]]
  cov_x_sci <- fm_data_inputs[["cov_x_sci"]]
  c_com_x <- fm_data_inputs[["c_com_x"]]
  t_com_i <- fm_data_inputs[["t_com_i"]]
  t_sci_i <- fm_data_inputs[["t_sci_i"]]
  spde <- fm_data_inputs[["spde"]]
  Aix_ij_com <- fm_data_inputs[["Aix_ij_com"]]
  Aix_w_com <- fm_data_inputs[["Aix_w_com"]]
  Aix_ij_sci <- fm_data_inputs[["Aix_ij_sci"]]
  Aix_w_sci <- fm_data_inputs[["Aix_w_sci"]]
  cov_x_pred <- fm_data_inputs[["cov_x_pred"]]
  Aix_ij_pred <- fm_data_inputs[["Aix_ij_pred"]]
  Aix_w_pred <- fm_data_inputs[["Aix_w_pred"]]
  W <- fm_data_inputs[["W"]]
  n_survey <- fm_data_inputs[["n_survey"]]
  MeshList_aniso <- fm_data_inputs[["MeshList_aniso"]]

  xfb_x <- NULL # TO DELETE
  weights_com <- 1 # TO DELETE
  
  result <- fm_build_data_params_map(
    SE = SE,
    data_source = data_source,
    data_obs = data_obs,
    samp_process = samp_process,
    b_constraint = b_constraint,
    cov_samp_process = cov_samp_process,
    const_spphab = const_spphab,
    biomass_temporal = biomass_temporal,
    sampling_temporal = sampling_temporal,
    anisotropy = anisotropy,
    lf_link = lf_link,
    b_com_i = b_com_i,
    mesh = mesh,
    time.step_df = time.step_df,
    loc_x = loc_x,
    y_com_i = y_com_i,
    y_sci_i = y_sci_i,
    cov_x_com = cov_x_com,
    cov_x_sci = cov_x_sci,
    xfb_x = xfb_x,
    c_com_x = c_com_x,
    t_com_i = t_com_i,
    weights_com = weights_com,
    t_sci_i = t_sci_i,
    spde = spde,
    Aix_ij_com = Aix_ij_com,
    Aix_w_com = Aix_w_com,
    Aix_ij_sci = Aix_ij_sci,
    Aix_w_sci = Aix_w_sci,
    cov_x_pred = cov_x_pred,
    Aix_ij_pred = Aix_ij_pred,
    Aix_w_pred = Aix_w_pred,
    W = W,
    n_survey = n_survey,
    MeshList_aniso = MeshList_aniso,
    EM = EM,
    ref_data = ref_data,
    month_ref = month_ref,
    Version = Version
  )
```



```{r tests-fm_build_data_params_map}
test_that("fm_build_data_params_map", {
  
  ## Settings all params
  
  SE <- 1
  data_source <- 1
  data_obs <- 2
  samp_process <- 0
  b_constraint <- 2
  const_spphab <- 1
  cov_samp_process <- 0
  biomass_temporal <- 1
  sampling_temporal <- 0
  anisotropy <- 0
  lf_link <- 0
  ref_data <- "com"
  EM <- "est_b"
  month_ref <- 1
  compute_sd <- FALSE
  
  fm_data_inputs <- fm_load_data()
  
  species <- fm_data_inputs[["species"]]
  b_com_i <- fm_data_inputs[["b_com_i"]]
  mesh <- fm_data_inputs[["mesh"]]
  time.step_df <- fm_data_inputs[["time.step_df"]]
  loc_x <- fm_data_inputs[["loc_x"]]
  y_com_i <- fm_data_inputs[["y_com_i"]]
  y_sci_i <- fm_data_inputs[["y_sci_i"]]
  cov_x_com <- fm_data_inputs[["cov_x_com"]]
  cov_x_sci <- fm_data_inputs[["cov_x_sci"]]
  c_com_x <- fm_data_inputs[["c_com_x"]]
  t_com_i <- fm_data_inputs[["t_com_i"]]
  t_sci_i <- fm_data_inputs[["t_sci_i"]]
  spde <- fm_data_inputs[["spde"]]
  Aix_ij_com <- fm_data_inputs[["Aix_ij_com"]]
  Aix_w_com <- fm_data_inputs[["Aix_w_com"]]
  Aix_ij_sci <- fm_data_inputs[["Aix_ij_sci"]]
  Aix_w_sci <- fm_data_inputs[["Aix_w_sci"]]
  cov_x_pred <- fm_data_inputs[["cov_x_pred"]]
  Aix_ij_pred <- fm_data_inputs[["Aix_ij_pred"]]
  Aix_w_pred <- fm_data_inputs[["Aix_w_pred"]]
  W <- fm_data_inputs[["W"]]
  n_survey <- fm_data_inputs[["n_survey"]]
  MeshList_aniso <- fm_data_inputs[["MeshList_aniso"]]

  xfb_x <- NULL # TO DELETE
  weights_com <- 1 # TO DELETE
  
  result <- fm_build_data_params_map(
    SE = SE,
    data_source = data_source,
    data_obs = data_obs,
    samp_process = samp_process,
    b_constraint = b_constraint,
    cov_samp_process = cov_samp_process,
    const_spphab = const_spphab,
    biomass_temporal = biomass_temporal,
    sampling_temporal = sampling_temporal,
    anisotropy = anisotropy,
    lf_link = lf_link,
    b_com_i = b_com_i,
    mesh = mesh,
    time.step_df = time.step_df,
    loc_x = loc_x,
    y_com_i = y_com_i,
    y_sci_i = y_sci_i,
    cov_x_com = cov_x_com,
    cov_x_sci = cov_x_sci,
    xfb_x = xfb_x,
    c_com_x = c_com_x,
    t_com_i = t_com_i,
    weights_com = weights_com,
    t_sci_i = t_sci_i,
    spde = spde,
    Aix_ij_com = Aix_ij_com,
    Aix_w_com = Aix_w_com,
    Aix_ij_sci = Aix_ij_sci,
    Aix_w_sci = Aix_w_sci,
    cov_x_pred = cov_x_pred,
    Aix_ij_pred = Aix_ij_pred,
    Aix_w_pred = Aix_w_pred,
    W = W,
    n_survey = n_survey,
    MeshList_aniso = MeshList_aniso,
    EM = EM,
    ref_data = ref_data,
    month_ref = month_ref,
    Version = Version
  )
  
  #' @description Testing that fm_build_data_params_map return a list
  expect_type(object = result, "list")
  
  #' @description Testing names of the list
  expect_named(result, c("data", "map", "params", "random"))
  
})
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_build_data_params.Rmd", vignette_name = "dev-Build data params", check = FALSE)

```

