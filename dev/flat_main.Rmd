---
title: "flat_main.Rmd"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

```{r message=FALSE}
library(dplyr)
library(INLA)
library(ggplot2)
library(sf)
library(stringr)
library(tidyr)
library(TMB)
library(tictoc)
library(testthat)
```

# `main.R`

This vignette runs a toy example of the FishMap spatio-temporal model. The execution comprises three steps : data preparation, model fitting and graph generation.

## part1: Data preparation

### `fm_load_data()` : prepare and load model inputs

This function Prepare all the necessary output for the model fitting. It will filter and shape the observation data (VMS and scientific). It will generate the spatial mesh for the study domain. All outputs are reported as part of a named list.
    
```{r function-fm_load_data}
#' Load and prepare data for model fitting
#'
#' @param species character Name of the species of interest, match the data folder name
#' @param fleet character Vector of conditional operation to filter fleets, the first one will be taken as reference level in the model
#' @param survey_data_file character Name of the Rdata file storing scientific observations
#' @param vmslogbook_data_file  character Name of the Rdata file storing vms x logbooks observations
#' @param study_domain_file  character Name of the Rdata file storing study domain informations
#' @param year_start integer Lower bound year filter to select data
#' @param year_end integer Upper bound year filter to select data
#' @param month_start integer Lower bound month filter to select data
#' @param month_end integer Upper bound month filter to select data
#' @param time_step character Time intervals, must be Month or Quarter 
#' @param k reduce the mesh size, smaller k reduces the number of knots at which the spatial random effect is computed
#' @param grid_xmin,grid_xmax,grid_ymin,grid_ymax  Build regular grid objects to create spatialpolygon based on raster
#'
#' @importFrom dplyr ungroup select filter arrange mutate
#' @importFrom stringr str_detect
#' @importFrom tictoc tic toc
# source domain_mesh_spde
#' @importFrom dplyr mutate select
#' @importFrom INLA inla.nonconvex.hull inla.mesh.2d inla.CRS inla.spde2.matern inla.mesh.create inla.spde.make.A
#' @importFrom sf st_as_sf st_intersects st_join st_coordinates
#' @importFrom sp SpatialPointsDataFrame CRS
# source shape_sci_data
#' @importFrom dplyr mutate inner_join ungroup select
#' @importFrom INLA inla.spde.make.A
#' @importFrom sf st_as_sf st_intersects st_join st_coordinates
# source shape_vms_logbook
#' @importFrom dplyr inner_join mutate select filter group_by count arrange full_join ungroup
#' @importFrom INLA inla.spde.make.A
#' @importFrom sf st_as_sf st_intersects st_join st_coordinates
#' @importFrom tidyr pivot_wider


#' @return list A named list of all necessary outputs for model fitting (step 2)
#' @export
#'
#' @examples
fm_load_data <- function(species = "Solea_solea",
                         fleet = c("OTB_DEF_>=70_0","OTB_CEP_>=70_0","OTT_DEF_>=70_0"),
                         survey_data_file = "survey_data.Rdata",
                         vmslogbook_data_file = "vmslogbook_data.Rdata",
                         study_domain_file = "study_domain.Rdata",
                         year_start = 2018,
                         year_end = 2018,
                         month_start = 11,
                         month_end = 11,
                         time_step = "Month",
                         k = 0.25,
                         grid_xmin = -6,
                         grid_xmax = 0,
                         grid_ymin = 42,
                         grid_ymax = 48
                         ) {
  ## Load data
  #-----------
  message("Running step 1 -loading data-")
  tic("Step 1 -loading data-")
  
  data_folder <- system.file(file.path("original_data",species), package = "FishMap") 
  script_folder <- system.file("original_scripts", package = "FishMap") 
  
  fitted_data <- "biomass" # "biomass" "presabs"
  
  # Scientific data
  n_survey <- 1 # number of surveys
  load(file.path(data_folder,survey_data_file))
  scientific_observation <- "CPUE" # 'CPUE' or 'Density'
  survey_data_0 <- survey_data %>% ungroup %>% dplyr::select(-layer)
  
  # 'VMS x logbook' data
  load(file.path(data_folder,vmslogbook_data_file))
  
  select_aggreg_level <- paste(fleet,collapse = "|")
  vmslogbook_data <- vmslogbook_data %>%
    filter(str_detect(LE_MET_level6,select_aggreg_level))
  
  vmslogbook_data$LE_MET_level6 <- factor(as.character(vmslogbook_data$LE_MET_level6),levels = fleet)
  
  vmslogbook_data_0 <- vmslogbook_data %>% ungroup %>% dplyr::select(-layer)
  
  ## Time series
  #-------------
  year_vec <- year_start:year_end
  month_vec <- month_start:month_end

  if(time_step == "Month"){
  
    time.step_df <- expand.grid(month_vec,year_vec)
    colnames(time.step_df) <- c("Month","Year")
  
    time.step_df <- time.step_df %>%
      arrange(Year,Month) %>%
      mutate(Month = ifelse(Month < 10,paste0("0",Month),Month)) %>%
      mutate(Year_Month = paste0(Year,"_",Month)) %>%
      mutate(t = 1:nrow(time.step_df))
    time.step_df$Year <- as.character(time.step_df$Year)
    time.step_df$Month <- as.character(time.step_df$Month)
  
  }else if(time_step == "Quarter"){
  
    time.step_df <- expand.grid(1:4,all_years)
    colnames(time.step_df) <- c("Quarter","Year")
  
    time.step_df <- time.step_df %>%
      arrange(Year,Quarter) %>%
      mutate(Quarter = ifelse(Quarter < 10,paste0("0",Quarter),Quarter)) %>%
      mutate(Year_Quarter = paste0(Year,"_",Quarter)) %>%
      mutate(t = 1:nrow(time.step_df))
    time.step_df$Year <- as.character(time.step_df$Year)
    time.step_df$Quarter <- as.character(time.step_df$Quarter)
  
  }
  
  
  ## Configure spatial domain
  #--------------------------
  grid_xmin <- grid_xmin
  grid_xmax <- grid_xmax
  grid_ymin <- grid_ymin
  grid_ymax <- grid_ymax
  
  grid_limit <- raster::extent(
    c(grid_xmin,
      grid_xmax,
      grid_ymin,
      grid_ymax)
  )
  
  grid_projection <- "+proj=longlat +datum=WGS84"
  
  resol <- 0.05 # resolution of the discretization grid
  create_mesh <- "from_shapefile"
  # from_shapefile: the mesh will be more regular on the grid
  # from_data: the mesh will be denser in the areas where there are data
  
  # Mesh parameterization
  # reduce the mesh size (k = 0.25 now) reduces the number of knots at which the spatial random effect is computed.
  k <- k
  Alpha <- 2
  
  load(file.path(data_folder,study_domain_file))
  
  ## Load domain / mesh / spde object
  source(file.path(script_folder,"domain_mesh_spde.R"), local=TRUE)
  
  ## Shape scientific data
  source(file.path(script_folder,"shape_sci_data_st.R"), local=TRUE)
  
  ## Shape commercial data
  source(file.path(script_folder,"shape_vmslogbook_data_st.R"), local=TRUE)
  
  if(fitted_data=="presabs"){
    y_com_i[which(y_com_i > 0)] <- 1
    y_sci_i[which(y_sci_i > 0)] <- 1
    lf_link <- 1 # logit link
  }
  
  
  ## Covariates
  #------------
  # load(file.path(data_folder,"bathy_pred.Rdata"))
  bathy_pred = rep(0,nrow(loc_x))
  cov_x_pred <- matrix(data = bathy_pred, ncol = 1)
  
  # load(file.path(data_folder,"bathy_com.Rdata"))
  bathy_com = rep(0,nrow(vmslogbook_data_2))
  cov_x_com <- matrix(data = bathy_com, ncol = 1)
  
  # load(file.path(data_folder,"bathy_sci.Rdata"))
  bathy_sci = rep(0,nrow(survey_data_2))
  cov_x_sci <- matrix(data = bathy_sci, ncol = 1)

  # finished step 1 -loading data-
  toc()

  # return outputs as named list
  return(list("species" = species,
              "b_com_i" = b_com_i,
              "mesh" = mesh,
              "time.step_df" = time.step_df,
              "loc_x" = loc_x,
              "y_com_i" = y_com_i,
              "y_sci_i" = y_sci_i,
              "cov_x_com" = cov_x_com,
              "cov_x_sci" = cov_x_sci,
              "c_com_x" = c_com_x,
              "t_com_i" = t_com_i,
              "t_sci_i" = t_sci_i,
              "spde" = spde,
              "Aix_ij_com" = Aix_ij_com,
              "Aix_w_com" = Aix_w_com,
              "Aix_ij_sci" = Aix_ij_sci,
              "Aix_w_sci" = Aix_w_sci,
              "cov_x_pred"=cov_x_pred,
              "Aix_ij_pred"=Aix_ij_pred,
              "Aix_w_pred"=Aix_w_pred,
              "W"=W,
              "n_survey" = n_survey,
              "MeshList_aniso" = MeshList_aniso
              ))
}
```
  
```{r preex-fm_load_data}
# run part1
fm_data_inputs <- fm_load_data()
```
  
```{r tests-fm_load_data}
test_that("fm_load_data works", {
  # The test are done by default with k = 0.25, which allow the use of small size objects
  
  test_resolution <- Sys.getenv("FISHMAP_TEST_RESOLUTION", unset = "small")
  
  # run part1
  if (test_resolution == "small") {
    fm_data_inputs <- fm_load_data(k = 0.25, month_start = 11, month_end = 11)
  } else if (test_resolution == "big") {
    fm_data_inputs <- fm_load_data(k = 0.75, month_start = 10, month_end = 12)
  }

  # Update expected outputs here
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    # save output depending if we are in flat or in test
    output_test_dir <- here::here("tests", "testthat")
    output_inst_dir <- here::here("inst", "examples")  
    
    if (test_resolution == "small") {
      readr::write_rds(x = fm_data_inputs,
                       file = file.path(output_inst_dir, paste0("part1_output_", test_resolution , ".rds")))
    } else if (test_resolution == "big") {
      # Multiple parts
      # output_test_dir
    }
  }
  
  # check output is saved as rds
  if (Sys.getenv("FISHMAP_UPDATE_OUTPUTS") == "TRUE") {
    output_dir <- Sys.getenv("FISHMAP_OUTPUT_DIR")

    #' @description Test to check if we can save output
    expect_true(file.exists(file.path(
      output_dir, paste0("part1_output", k , ".rds")
    )))
  }
  
  # Check `fm_load_data` output values
  
  #' @description Testing the result of `fm_load_data` is a list
  expect_type(object = fm_data_inputs,  "list")
  
  #' @description Testing names of the list return by `fm_load_data`
  expect_named(
    object = fm_data_inputs,
    expected = c(
      "species",
      "b_com_i",
      "mesh",
      "time.step_df",
      "loc_x",
      "y_com_i",
      "y_sci_i",
      "cov_x_com",
      "cov_x_sci",
      "c_com_x",
      "t_com_i",
      "t_sci_i",
      "spde",
      "Aix_ij_com",
      "Aix_w_com",
      "Aix_ij_sci",
      "Aix_w_sci",
      "cov_x_pred",
      "Aix_ij_pred",
      "Aix_w_pred",
      "W",
      "n_survey",
      "MeshList_aniso"
    )
  )
  
  #' @description Testing types inside the list returned by `fm_load_data`
  expect_type(fm_data_inputs[["species"]], "character")
  expect_type(fm_data_inputs[["b_com_i"]], "double")
  expect_s3_class(fm_data_inputs[["mesh"]], "inla.mesh")
  expect_s3_class(fm_data_inputs[["time.step_df"]], "data.frame")
  expect_s3_class(fm_data_inputs[["loc_x"]], "data.frame")
  expect_type(fm_data_inputs[["y_com_i"]], "double")
  expect_type(fm_data_inputs[["y_sci_i"]], "double")
  expect_true(is.matrix(fm_data_inputs[["cov_x_com"]]))
  expect_true(is.matrix(fm_data_inputs[["cov_x_sci"]]))
  expect_true(is.array(fm_data_inputs[["c_com_x"]]))
  expect_type(fm_data_inputs[["t_com_i"]], "integer")
  expect_type(fm_data_inputs[["t_sci_i"]], "integer")
  expect_type(fm_data_inputs[["spde"]], "list")
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_com"]]))
  expect_type(fm_data_inputs[["Aix_w_com"]], "double")
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_sci"]]))
  expect_type(fm_data_inputs[["Aix_w_sci"]], "double")
  expect_true(is.matrix(fm_data_inputs[["cov_x_pred"]]))
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_pred"]]))
  expect_type(fm_data_inputs[["Aix_w_pred"]], "double")
  expect_type(fm_data_inputs[["W"]], "double")
  expect_type(fm_data_inputs[["n_survey"]], "double")
  expect_type(fm_data_inputs[["MeshList_aniso"]], "list")
  
  # retrieve tmp name of mesh dir, which changes for each execution
  mesh_dir <- dirname(path = fm_data_inputs$mesh$meta$prefix)
  mesh_aniso_dir <- dirname(path = fm_data_inputs$MeshList_aniso$anisotropic_spde$mesh$meta$prefix)

  #' @description Testing that tmpdir of the mesh exists
  expect_true(dir.exists(mesh_dir))
  expect_true(dir.exists(mesh_aniso_dir))
  
  # Load previous run saved in testdir
  # to change this file, follow dev/0-dev_history.Rmd instructions
  # If in flat main != in tests
  the_path <- file.path(paste0("part1_output", k , ".rds"))
  if (!file.exists(the_path)) {
    # In case we are in the flat file
    the_path <- file.path("tests", "testthat", the_path)
    if (!file.exists(the_path)) {stop(the_path, "does not exist. Was the expected output created: See vignette to create outputs")}
  }
  expected_output <- readr::read_rds(the_path)
  
  # homogenize tmp dir value tested in above test
  expected_output$mesh$meta$prefix <-
    fm_data_inputs$mesh$meta$prefix
  expected_output$MeshList_aniso$anisotropic_spde$mesh$meta$prefix <-
    fm_data_inputs$MeshList_aniso$anisotropic_spde$mesh$meta$prefix
  
  # sort list and data frame elements to avoid order discrepancies
  # Dans un flat_utils => @noRd
  resort_all <- function(x) {
    x <- x[sort(names(x))]
    
    result <- lapply(x, function(x) {
      if (inherits(x, c("data.frame", 'list'))) {
        x[sort(names(x))]
      } else{
        x
      }
    })
    
    result
  }
  resorted_result <- resort_all(fm_data_inputs)
  resorted_expected <- resort_all(expected_output)
  
  # remove name attributes (likely generated by a specific version of {sf})
  attr(resorted_result$loc_x$long, which = "names") <- NULL
  attr(resorted_result$loc_x$lati, which = "names") <- NULL
  attr(resorted_expected$loc_x$long, which = "names") <- NULL
  attr(resorted_expected$loc_x$lati, which = "names") <- NULL
  
  #' @description Testing that the result of `fm_load_data` is stable
  expect_equal(object = resorted_result,
               expected = resorted_expected)
  
})
```

## part2: fit model

### `fm_fit_model()`: compile model and fit to data

This function will fit the model to the observation data. It will compile the model cpp file. It will fit the model to the input data generated from `fm_load_data()` and provide the results as a named list.

    
```{r function-fm_fit_model}
#' Compile model and fit to data
#'
#' @param fm_data_inputs list Named list obtained from `fm_load_data()`
#' @param SE integer run ADREPORT - 0: no, 1: yes
#' @param data_source integer 1: integrated model (scientific + commercial data), 2: scientific model, 3: commercial model
#' @param data_obs integer observation model for biomass - 1: zero_inflated gamma, 2: zero-inflated lognormal, 3: lognormal
#' @param samp_process integer Sampling process - 0: no sampling process, 1: inhomogeneous Poisson point process
#' @param b_constraint integer put constraint on b parameters - 1: b are positive, 2: no constraints
#' @param const_spphab integer Species-habitat relationship - 1: constant in time
#' @param cov_samp_process integer covariate in the sampling process - 0: none, 1: covariate in the samplign process
#' @param biomass_temporal integer Account for temporal correlation in biomass - 0: no, 1: AR1
#' @param sampling_temporal integer Account for temporal correlation in sampling process - 0: no, 1: AR1
#' @param anisotropy integer Account for anisotropy
#' @param lf_link integer link function of the latent field - 0: log (biomass data), 1: logit (presence absence data)
#' @param ref_data character reference data - "com": commercial (default) or "sci": scientific
#' @param EM character "est_b": b is estimated, "fix_b": b is fixed
#' @param month_ref integer reference month (default is 1 for January)
#' @param compute_sd logical compute SD report (time-consumming)
#'
#' @importFrom stats nlminb
#' @importFrom stringr str_detect
#' @importFrom tictoc tic toc
#' @importFrom TMB compile dynlib MakeADFun sdreport
#  source build_data_params_map
#' @importFrom INLA inla.as.dgTMatrix
#' @importFrom stringr str_detect
#' 
#' @return list A named list of all necessary outputs for generating graphs (step 3)
#' @export
#'
#' @examples
fm_fit_model <- function(fm_data_inputs,
                         SE = 1,
                         data_source = 1,
                         data_obs = 2,
                         samp_process = 0,
                         b_constraint = 2,
                         const_spphab = 1,
                         cov_samp_process = 0,
                         biomass_temporal = 1,
                         sampling_temporal = 0,
                         anisotropy = 0,
                         lf_link = 0,
                         ref_data = "com",
                         EM = "est_b",
                         month_ref = 1,
                         compute_sd = FALSE) {
  ## Fit model
  #-----------
  message("Running step 2 -compile model-")
  tic("Step 2 -compile model-")
  
  ## Dependencies from Part1 outputs
  species <- fm_data_inputs[["species"]]
  b_com_i <- fm_data_inputs[["b_com_i"]]
  mesh <- fm_data_inputs[["mesh"]]
  time.step_df <- fm_data_inputs[["time.step_df"]]
  loc_x <- fm_data_inputs[["loc_x"]]
  y_com_i <- fm_data_inputs[["y_com_i"]]
  y_sci_i <- fm_data_inputs[["y_sci_i"]]
  cov_x_com <- fm_data_inputs[["cov_x_com"]]
  cov_x_sci <- fm_data_inputs[["cov_x_sci"]]
  c_com_x <- fm_data_inputs[["c_com_x"]]
  t_com_i <- fm_data_inputs[["t_com_i"]]
  t_sci_i <- fm_data_inputs[["t_sci_i"]]
  spde <- fm_data_inputs[["spde"]]
  Aix_ij_com <- fm_data_inputs[["Aix_ij_com"]]
  Aix_w_com <- fm_data_inputs[["Aix_w_com"]]
  Aix_ij_sci <- fm_data_inputs[["Aix_ij_sci"]]
  Aix_w_sci <- fm_data_inputs[["Aix_w_sci"]]
  cov_x_pred <- fm_data_inputs[["cov_x_pred"]]
  Aix_ij_pred <- fm_data_inputs[["Aix_ij_pred"]]
  Aix_w_pred <- fm_data_inputs[["Aix_w_pred"]]
  W <- fm_data_inputs[["W"]]
  n_survey <- fm_data_inputs[["n_survey"]]
  MeshList_aniso <- fm_data_inputs[["MeshList_aniso"]]
  
  # script location
  data_folder <- system.file(file.path("original_data",species), package = "FishMap")
  script_folder <- system.file("original_scripts", package = "FishMap")
  
  xfb_x <- NULL # TO DELETE
  weights_com <- 1 # TO DELETE
  
  ## Build Data, Params and Map objects for model fitting
  source(file.path(script_folder,"build_data_params_map.R"), local=TRUE)
  
  # Add link to path
  if (.Platform$OS.type == "windows"){
    fixwinpath <- function(){
      PATH <- Sys.getenv("PATH")
      PATH <- paste0(R.home(), "/bin/x64;", PATH)
      PATH <- paste0("c:/Rtools/mingw64/bin;", PATH)
      Sys.setenv(PATH=PATH)
    }
    fixwinpath()
    shell("where g++")
    shell("where gdb")
    shell("where Rterm")
  }
  
  ## Model compilation
  compile(system.file("model.cpp", package = "FishMap"),"-O1 -g",DLLFLAGS="")
  dyn.load( dynlib(file.path(system.file(package = "FishMap"),"model") ))
  
  # finished step 2 -compile model-
  toc()
  
  ## Fit model
  message("Running step 3 -fit model-")
  tic("Step 3 -fit model-")
  
  # ## Debugging
  # source("r/function/MakeADFun_windows_debug.R")
  # MakeADFun_windows_debug(cpp_name = "inst/model",  data=Data, parameters=Params,  random=Random)
  # gdbsource("inst/model.R",interactive = T) ## Non-interactive
  # dyn.unload( dynlib( "inst/model" ) )
  # #-----------
  
  obj = MakeADFun( data=Data, parameters=Params,  random=Random, map = Map, silent = TRUE,hessian = TRUE )
  # next line takes a long time ----
  obj$fn( obj$par )
  
  # Parameters boundary for optimization
  Lower <- -50
  Upper <- 50
  
  if(T %in% str_detect(names(obj$par),"rho_")){ # constraints on the bounds of rho
    
    Lower <- rep(-50,length(obj$par))
    Upper <- rep(50,length(obj$par))
    
    Lower[which(str_detect(names(obj$par),"rho_"))] <- -0.99
    Upper[which(str_detect(names(obj$par),"rho_"))] <- 0.99
    
  }
  
  # next line takes a VERY long time ----
  opt = nlminb( start=obj$par, objective=obj$fn, gradient=obj$gr, lower=Lower, upper=Upper, control=list(trace=1, maxit=200))
  opt[["diagnostics"]] = data.frame( "Param"=names(obj$par), "Lower"=-Inf, "Est"=opt$par, "Upper"=Inf, "gradient"=obj$gr(opt$par) )
  
  report = obj$report() # output values
  converge=opt$convergence # convergence test
  # next line takes a VERY long time ----
  if(compute_sd) SD = sdreport(obj,bias.correct=FALSE,ignore.parm.uncertainty=TRUE) # compute standard deviation

  dyn.unload( dynlib( file.path(system.file(package = "FishMap"),"model")))
  
  # Finished step 3 - fit model-
  toc()
  
  # return outputs as named list
  return(list("time.step_df" = time.step_df,
              "loc_x" = loc_x,
              "report" = report,
              "samp_process" = samp_process,
              "converge" = converge
              )
         )
  
}
```
  
```{r preex-fm_fit_model}
# run part 2
fm_model_results <- fm_fit_model(fm_data_inputs)
```
  
```{r tests-fm_fit_model}
test_that("fm_fit_model works", {
  
  # You can test your model with another parameter k. By construction, the first test of a value of k will always pass. Do not use for CI. You must run the tests locally with FISHMAP_UPDATE_OUTPUTS env at TRUE to store the rds file.
  
  if(Sys.getenv("FISHMAP_K_PARAM") != ""){
    k <- as.numeric(Sys.getenv("FISHMAP_K_PARAM"))
  }else{
    k <- 0.25
  }
  
  # run part1
  fm_data_inputs <- fm_load_data(
    k = k
  )
  
  # run part2
  withr::with_seed(1234,{
    fm_model_results <- fm_fit_model(fm_data_inputs)
  })
  
    
  # save part2 outputs, one for each k tested
  if (Sys.getenv("FISHMAP_UPDATE_OUTPUTS") == "TRUE") {
    # setup save dir, create it if necessary
    output_dir <- Sys.getenv("FISHMAP_OUTPUT_DIR")
    if (isFALSE(dir.exists(output_dir))){
      dir.create(output_dir)
    }
    # save output
    saveRDS(object = fm_model_results, file = file.path(output_dir, paste0("part2_output", k ,".rds")))
    
    # TODO To reduce size of the rds, we have to only save some parts, not all
    # saveRDS(object = fm_model_results, file = file.path(paste0("part2_output", k ,".rds")))
  }

  
  # check output is saved as rds
  if (Sys.getenv("FISHMAP_UPDATE_OUTPUTS") == "TRUE") {
    output_dir <- Sys.getenv("FISHMAP_OUTPUT_DIR")
    
    #' @description Test to check if we can save output
    expect_true(file.exists(file.path(output_dir, paste0("part2_output", k ,".rds"))))
  }
  
  # Check resultats of model 
  
  #' @description Testing the result of `fm_fit_model` is a list
  expect_type(object = fm_model_results,  "list")
  
  #' @description Testing names of the list return by `fm_fit_model` 
  expect_named(
    object = fm_model_results, 
    expected = c(
      "time.step_df", 
      "loc_x" ,      
      "report" ,   
      "samp_process", 
      "converge" )
    )
  
  
  #' @description Testing types inside the list return by `fm_fit_model` 
  expect_s3_class(fm_model_results$time.step_df, "data.frame")
  expect_s3_class(fm_model_results$loc_x, "data.frame")
  expect_type(fm_model_results$report, "list")
  expect_type(fm_model_results$samp_process, "double")
  expect_type(fm_model_results$converge, "integer")
  
  # TODO To reduce size of the rds, we have to check only some parts
  # #' @description Testing that the result of `fm_fit_model` is stable
  # expect_equal(
  #   object = fm_model_results,
  #   expected = readRDS(file.path(paste0("part2_output", k ,".rds")))
  # )
  
})
```

## part3: generate output graphs

### `fm_generate_graphs()` : generate output graphs

This function will generate graphs of the model predictions. It will use as input the data generated from `fm_fit_model()` and provide the predictive plot within a named list. Is the sampling process is activated (`samp_process = 1`), an additionnal graphic for eta result will be generated.

```{r function-fm_generate_graphs}
#' generate output graphs
#' 
#' @param fm_model_results list Named list obtained from `fm_fit_model()`
#' 
#' @importFrom dplyr mutate inner_join
#' @importFrom ggplot2 ggplot geom_sf aes scale_color_distiller facet_wrap
#' @importFrom sf st_as_sf
#' @importFrom stringr str_replace
#' @importFrom tictoc tic toc
#' @importFrom tidyr pivot_longer starts_with
#' 
#' @return list A named list of all generated graphs (step 3)
#' 
#' @export
fm_generate_graphs <- function(fm_model_results) {
  ## Plot model outputs
  #--------------------
  message("Running step 4 -plot graphs-")
  tic("Step 4 -plot graphs-")
  
  ## Dependencies from Part1 factorization
  loc_x <- fm_model_results[["loc_x"]]
  time.step_df <- fm_model_results[["time.step_df"]]
  report <- fm_model_results[["report"]]
  samp_process <- fm_model_results[["samp_process"]]
  
  if (nrow(time.step_df) > 1) {
    pred_df <-
      cbind(loc_x[, c("long", "lati")], S_x = report$S_p[1:nrow(loc_x), ]) %>%
      pivot_longer(cols = starts_with("S_x."),
                   names_to = "t",
                   values_to = "S_x") %>%
      mutate(t = as.numeric(str_replace(t, "S_x.", ""))) %>%
      inner_join(time.step_df)
    
    pred_sf <- st_as_sf(pred_df, coords = c("long", "lati"))
    
    pred_plot <- ggplot(pred_sf) +
      geom_sf(aes(col = S_x)) +
      scale_color_distiller(palette = "Spectral") +
      facet_wrap(. ~ Year_Month)
    
    
  } else if (nrow(time.step_df) == 1) {
    pred_df <-
      cbind(loc_x[, c("long", "lati")], S_x = report$S_p[1:nrow(loc_x), ])
    
    pred_sf <- st_as_sf(pred_df, coords = c("long", "lati"))
    
    pred_plot <- ggplot(pred_sf) +
      geom_sf(aes(col = S_x)) +
      scale_color_distiller(palette = "Spectral")
    
  }
  
  plot(pred_plot)
  
  # plot eta if sampling is active
  if (samp_process == 1) {
    for (i in 1:3) {
      eta_df <-
        cbind(loc_x[, c("long", "lati")], eta = report$lambda_p[1:nrow(loc_x), , i]) %>%
        pivot_longer(
          cols = starts_with("eta."),
          names_to = "t",
          values_to = "eta"
        ) %>%
        mutate(t = as.numeric(str_replace(t, "eta.", ""))) %>%
        inner_join(time.step_df)
      
      eta_sf <- st_as_sf(eta_df, coords = c("long", "lati"))
      
      eta_plot <- ggplot(eta_sf) +
        geom_sf(aes(col = log(eta))) +
        scale_color_distiller(palette = "Spectral") +
        facet_wrap(. ~ Year_Month)
      
      plot(eta_plot)
    }
  }
  
  # finished step 4 -plot graph-
  toc()
  
  # return outputs as named list
  output_list <- list("pred_plot" = pred_plot)
  
  # return eta plot if sampling is on
  if (samp_process == 1) {
    output_list[["eta_plot"]] <- eta_plot
  }
  return(output_list)
  
}
```
  
```{r preex-fm_generate_graphs}
# run part 3
fm_generate_graphs(fm_model_results)
```
  
```{r tests-fm_generate_graphs}
test_that("fm_generate_graphs works", {
  
  # run part1
  fm_data_inputs <- fm_load_data()
  
  # run part2
  fm_model_results <- fm_fit_model(fm_data_inputs)
  
  # run part3
  fm_graph_results <- fm_generate_graphs(fm_model_results)
  
  # save part3 outputs
  if (Sys.getenv("FISHMAP_UPDATE_OUTPUTS") == "TRUE") {
    # setup save dir, create it if necessary
    output_dir <- Sys.getenv("FISHMAP_OUTPUT_DIR")
    if (isFALSE(dir.exists(output_dir))){
      dir.create(output_dir)
    }
    # save output
    saveRDS(object = fm_model_results, file = file.path(output_dir, "part3_output.rds"))
  }
  
  # check output is a list
  expect_true(object = inherits(x = fm_model_results,
                                what = "list"))
  
  # check pred_plot output is a ggplot object
  expect_equal(object = class(fm_graph_results[["pred_plot"]]),
               expected = c("gg", "ggplot"))
  
  # check output is saved as rds
  if (Sys.getenv("FISHMAP_UPDATE_OUTPUTS") == "TRUE") {
    output_dir <- Sys.getenv("FISHMAP_OUTPUT_DIR")
    expect_true(file.exists(file.path(output_dir, "part3_output.rds")))
  }
  
})
```
  

```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_main.Rmd", check = FALSE,
               vignette_name = "user - running fishmap")

# To perform check, please go to `dev/0_dev_history.Rmd` and run the section `Use everytime needed`
```

