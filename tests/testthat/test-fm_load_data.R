# WARNING - Generated by {fusen} from dev/flat_fm_load_data.Rmd: do not edit by hand

test_that("fm_load_data works", {
  
  # You can test your model for small datas or big datas. You must run the tests locally with FISHMAP_UPDATE_OUTPUTS env at TRUE to store the rds file.
  
  test_resolution <- Sys.getenv("FISHMAP_TEST_RESOLUTION", unset = "small")
  
  if(test_resolution == "small"){
    k = 0.25
    month_start = 11
    month_end = 11
  }else if (test_resolution == "big") {
    k = 0.75
    month_start = 10
    month_end = 12
  }
  
  # Check `fm_load_data` input values
  
  #' @description Testing the inputs of `fm_load_data` are correct
  expect_error(object = fm_load_data(fitted_data = "notagoodinput"),
               regexp = "'arg' should be one of .biomass., .presabs.")
  expect_error(object = fm_load_data(time_step = "notagoodinput"),
               regexp = "'arg' should be one of .Month., .Quarter.")
  
  # run part1
  survey_data_file <- system.file("original_data",
                                  "Solea_solea",
                                  "survey_data.Rds",
                                  package = "FishMap"
  )
  
  survey_data <- readr::read_rds(file = survey_data_file)
  
  vmslogbook_data_file <- system.file("original_data",
                                      "Solea_solea",
                                      "vmslogbook_data.Rds",
                                      package = "FishMap"
  )
  
  vmslogbook_data <- readr::read_rds(file = vmslogbook_data_file)
  
  study_domain_file <- system.file("original_data",
                                   "Solea_solea",
                                   "study_domain.Rds",
                                   package = "FishMap"
  )
  
  study_domain <- readr::read_rds(file = study_domain_file)
  
  fm_data_inputs <- fm_load_data(species = "Solea_solea",
                                 fleet = c("OTB_DEF_>=70_0","OTB_CEP_>=70_0","OTT_DEF_>=70_0"),
                                 fitted_data = "biomass",
                                 survey_data = survey_data,
                                 vmslogbook_data = vmslogbook_data,
                                 study_domain = study_domain,
                                 year_start = 2018,
                                 year_end = 2018,
                                 month_start = month_start,
                                 month_end = month_end,
                                 time_step = "Month",
                                 k = k,
                                 grid_xmin = -6,
                                 grid_xmax = 0,
                                 grid_ymin = 42,
                                 grid_ymax = 48)
  
  
  # Update expected outputs here
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    # save output depending if we are in flat or in test
    output_inst_dir <- here::here("inst", "examples") 
    
    if (test_resolution == "small") {
      # save output data in example dir
      readr::write_rds(x = fm_data_inputs,
                       file = file.path(output_inst_dir, paste0("part1_output_", test_resolution , ".rds")))
    }else if (test_resolution == "big") {
      
      readr::write_rds(x = fm_data_inputs,
                       file = file.path("data", paste0("part1_output_", test_resolution , ".rds")))
    }
  }
  
  # check output is saved as rds
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    
    output_inst_dir <- here::here("inst", "examples")
    
    if (test_resolution == "small") {
      
      #' @description Test to check if we can save output for small
      expect_true(
        file.exists(
          file.path(output_inst_dir, paste0("part1_output_", test_resolution , ".rds"))
        )
      )
      
    }else if (test_resolution == "big") {
      
      #' @description Test to check if we can save output for big
      expect_true(
        file.exists(
          file.path("data", paste0("part1_output_", test_resolution , ".rds"))
        )
      )
      
    }
    
  }
  
  # Check `fm_load_data` output values
  
  #' @description Testing the result of `fm_load_data` is a list
  expect_type(object = fm_data_inputs,  "list")
  
  #' @description Testing names of the list return by `fm_load_data`
  expect_named(
    object = fm_data_inputs,
    expected = c(
      "species",
      "b_com_i",
      "mesh",
      "time.step_df",
      "loc_x",
      "y_com_i",
      "y_sci_i",
      "cov_x_com",
      "cov_x_sci",
      "c_com_x",
      "t_com_i",
      "t_sci_i",
      "spde",
      "Aix_ij_com",
      "Aix_w_com",
      "Aix_ij_sci",
      "Aix_w_sci",
      "cov_x_pred",
      "Aix_ij_pred",
      "Aix_w_pred",
      "W",
      "n_survey",
      "MeshList_aniso"
    )
  )
  
  #' @description Testing types inside the list returned by `fm_load_data`
  expect_type(fm_data_inputs[["species"]], "character")
  expect_type(fm_data_inputs[["b_com_i"]], "double")
  # expect_s3_class(fm_data_inputs[["mesh"]], "inla.mesh")
  expect_s3_class(fm_data_inputs[["time.step_df"]], "data.frame")
  expect_s3_class(fm_data_inputs[["loc_x"]], "data.frame")
  expect_type(fm_data_inputs[["y_com_i"]], "double")
  expect_type(fm_data_inputs[["y_sci_i"]], "double")
  expect_true(is.matrix(fm_data_inputs[["cov_x_com"]]))
  expect_true(is.matrix(fm_data_inputs[["cov_x_sci"]]))
  expect_true(is.array(fm_data_inputs[["c_com_x"]]))
  expect_type(fm_data_inputs[["t_com_i"]], "integer")
  expect_type(fm_data_inputs[["t_sci_i"]], "integer")
  expect_type(fm_data_inputs[["spde"]], "list")
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_com"]]))
  expect_type(fm_data_inputs[["Aix_w_com"]], "double")
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_sci"]]))
  expect_type(fm_data_inputs[["Aix_w_sci"]], "double")
  expect_true(is.matrix(fm_data_inputs[["cov_x_pred"]]))
  expect_true(is.matrix(fm_data_inputs[["Aix_ij_pred"]]))
  expect_type(fm_data_inputs[["Aix_w_pred"]], "double")
  expect_type(fm_data_inputs[["W"]], "double")
  expect_type(fm_data_inputs[["n_survey"]], "double")
  # expect_type(fm_data_inputs[["MeshList_aniso"]], "list")
  
  # Testing for small model
  if(test_resolution == "small"){
    
    expected_outputs <- readr::read_rds(
      system.file(
        "examples",
        paste0("part1_output_", test_resolution , ".rds"),
        package = "FishMap")
    )
  }else if(test_resolution == "big"){
    expected_outputs <- readr::read_rds(
      file.path("data", paste0("part1_output_", test_resolution , ".rds"))
      )
    }
    
    # sort list and data frame elements to avoid order discrepancies
    resort_all <- function(x) {
      x <- x[sort(names(x))]
      
      result <- lapply(x, function(x) {
        if (inherits(x, c("data.frame", 'list'))) {
          x[sort(names(x))]
        } else{
          x
        }
      })
      
      result
    }
    resorted_result <- resort_all(fm_data_inputs)
    resorted_expected <- resort_all(expected_outputs)
    
    # remove name attributes (likely generated by a specific version of {sf})
    attr(resorted_result$loc_x$long, which = "names") <- NULL
    attr(resorted_result$loc_x$lati, which = "names") <- NULL
    attr(resorted_expected$loc_x$long, which = "names") <- NULL
    attr(resorted_expected$loc_x$lati, which = "names") <- NULL
    
    #' @description Testing that the result of `fm_load_data` is stable
    expect_equal(object = resorted_result$loc_x,
                 expected = resorted_expected$loc_x)
    ## ADD OTHER OBJECTS

  
})
