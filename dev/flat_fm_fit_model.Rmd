---
title: "flat_fm_fit_model.Rmd empty"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r development, include=FALSE}
library(testthat)
```

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

# fm_build_data_params_map

```{r function-fm_build_data_params_map}
#' function to build data
#'
#' @inheritParams fm_fit_model 
#' @param b_com_i b_com_i
#' @param mesh mesh
#' @param time.step_df time.step_df
#' @param loc_x loc_x
#' @param y_com_i y_com_i
#' @param y_sci_i y_sci_i
#' @param cov_x_com cov_x_com
#' @param cov_x_sci cov_x_sci
#' @param xfb_x   xfb_x
#' @param c_com_x c_com_x
#' @param t_com_i t_com_i
#' @param weights_com weights_com
#' @param t_sci_i t_sci_i
#' @param spde spde
#' @param Aix_ij_com Aix_ij_com
#' @param Aix_w_com Aix_w_com
#' @param Aix_ij_sci Aix_ij_sci
#' @param Aix_w_sci Aix_w_sci 
#' @param cov_x_pred cov_x_pred 
#' @param Aix_ij_pred Aix_ij_pred 
#' @param Aix_w_pred Aix_w_pred 
#' @param W W 
#' @param n_survey n_survey 
#' @param MeshList_aniso MeshList_aniso 
#' @param Version Version
#' 
#' @importFrom INLA inla.as.dgTMatrix
#' @importFrom splancs splancs
#' @importFrom stringr str_detect
#'
#' @return list
#'
fm_build_data_params_map <- function(SE, data_source, data_obs, samp_process, b_constraint, cov_samp_process, const_spphab, biomass_temporal, sampling_temporal, anisotropy, lf_link, b_com_i, mesh, time.step_df, loc_x, y_com_i, y_sci_i, cov_x_com, cov_x_sci, xfb_x, c_com_x, t_com_i, weights_com, t_sci_i, spde, Aix_ij_com, Aix_w_com, Aix_ij_sci, Aix_w_sci, cov_x_pred, Aix_ij_pred, Aix_w_pred, W, n_survey, MeshList_aniso, EM, ref_data, month_ref, Version) {
  options_vec = c('SE'=SE, # run ADREPORT
                  'data_source' = data_source, # 1: integrated, 2: scientific, 3: commercial
                  'data_obs' = data_obs,  # 1 : zinfgamma, 2 : zinflognormal
                  'samp_process' = samp_process, # 1: sampling process is activated, else : it is ignored
                  'b_constraint' = b_constraint, # 1 : b > 0 | 2 : b is free
                  'cov_samp_process' = cov_samp_process, # 0: no covariate in the sampling process, 1: covariate in the samplign process
                  'const_spphab' = const_spphab, # 1: constant species-habitat relationship in time
                  'biomass_temporal' = biomass_temporal, # Type of temporal correlation in biomass field - 0: none, 1: AR1
                  'sampling_temporal' = sampling_temporal, # Type of temporal correlation in sampling process - 0: none, 1: AR1
                  'anisotropy' = anisotropy, # 0: no anisotropy, 1: anisotropy
                  'lf_link' = lf_link # latent field link function. 0: log link, 1: logit link
  )
  
  n_com.fleets = length(unique(b_com_i)) # number of fleets
  
  # Init values on random effect
  deltainput_x = matrix(0,nrow = mesh$n, ncol = length(time.step_df$t)) # when SPDE approach
  etainput_x = array(0,c(mesh$n,length(time.step_df$t),n_com.fleets))
  
  ## Data & Params
  Map = list()
  Random = c()
  if(data_source == 1){   # Integrated model (scientific_commercial)
    
    Data = list( "options_vec"=options_vec,
                 
                 "n_x" = mesh$n, # number of nodes in the mesh
                 "n_t" = nrow(time.step_df), # number of time steps
                 "n_p" = nrow(loc_x), # number of cells in the prediction grid
                 "n_com_i" = length(y_com_i), # number of commercial samples
                 "n_sci_i" = length(y_sci_i), # number of scientific samples
                 "n_eta" = n_com.fleets, # number of vessels
                 "n_S" = 1+n_com.fleets, # number of range and marginal variance parameters
                 
                 "cov_x_com"=cov_x_com, # covariate of the biomass field
                 "cov_x_sci"=cov_x_sci,
                 
                 "cov_fb"=if(is.null(xfb_x)){as.matrix(rep(1,nrow(cov_x_com)))}else{xfb_x}, # covariate for the commercial sampling equation
                 
                 "c_com_x"=c_com_x, # matrix of fleet counts at each time step in each cells
                 "y_com_i"=y_com_i, # commercial CPUE
                 "b_com_i" = (as.numeric(b_com_i)-1), # fleet index
                 "t_com_i" = t_com_i-1, # time step for ith observation of the commercial data
                 "q2_com" = rep(1,length(unique(b_com_i))), # commercial catchability
                 "weights_com" = weights_com, # weighting factor for commercial data
                 
                 "y_sci_i"=y_sci_i, # scientific CPUE
                 "t_sci_i" = t_sci_i-1, # time step for ith observation of the scientific data
                 "q2_sci" =  1,  # scientific catchability
                 
                 "spde"=spde, # SPDE objects
                 "spde_aniso" =list(),
                 "M0"=spde$M0,
                 "M1"=spde$M1,
                 "M2"=spde$M2,
                 
                 "Aix_ij_com"=Aix_ij_com,
                 "Aix_w_com"=Aix_w_com,
                 
                 "Aix_ij_sci"=Aix_ij_sci,
                 "Aix_w_sci"=Aix_w_sci,
                 
                 "cov_fb_mesh"=if(is.null(xfb_x)){as.matrix(rep(1,mesh$n))}else{xfb_x},
                 
                 "cov_x_pred"=cov_x_pred,
                 "cov_fb_pred"=if(is.null(xfb_x)){as.matrix(rep(1,nrow(cov_x_pred)))}else{xfb_x},
                 "Aix_ij_pred"=Aix_ij_pred,
                 "Aix_w_pred"=Aix_w_pred,
                 "W"=W
    )
    
    Params = list("beta_j0"=0,
                  "beta_j0season"=rep(0,nrow(time.step_df)),
                  "beta_j0year"=rep(0,nrow(time.step_df)),
                  "beta_j"=array(0,c(nrow(time.step_df),ncol(Data$cov_x_com))), # linear predictor for abundance
                  "beta_fb0"=rep(0,n_com.fleets),
                  "beta_fb0season"=matrix(0,nrow = nrow(time.step_df),ncol = n_com.fleets),
                  "beta_fb0year"=matrix(0,nrow = nrow(time.step_df),ncol = n_com.fleets),
                  "beta_fb"=matrix(0,nrow = ncol(Data$cov_fb), ncol = n_com.fleets), # additionnal linear predictor for sampling intensity
                  "par_b"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_bseason"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_byear"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_bseasonyear"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "logta_S"=rep(0,1+n_com.fleets), # parameters of SPDE object (see below)
                  "logtaAR1_S"=rep(0,1+n_com.fleets), # parameters of SPDE object (see below)
                  "logkappa_S"=rep(0,1+n_com.fleets),
                  "deltainput_x"=deltainput_x, # input for random noise
                  "epsiloninput_x"=deltainput_x,
                  "etainput_x"=etainput_x,
                  "psiinput_x"=etainput_x,
                  "logSigma_com"=rep(0,n_com.fleets),
                  "logSigma_sci"=log(1),
                  
                  "q1_com"=rep(0,n_com.fleets),
                  "q1_sci"=rep(0,n_survey),
                  
                  "k_com" = rep(1,c(n_com.fleets)),
                  "k_sci" = 1,
                  
                  "rho_epsilon" = 0,
                  "rho_psi" = 0,
                  "ln_Hdelta_input" = rep(0, 2),
                  "ln_Heta_input" = rep(0, 2)
    )
    
    
    
  }else if(data_source == 2){ # scientific model (scientific_only)
    
    Data = list( "options_vec"=options_vec,
                 
                 "n_x" = mesh$n, # number of cells
                 "n_t" = nrow(time.step_df), # number of time steps
                 "n_p" = nrow(loc_x),
                 "n_sci_i" = length(y_sci_i), # number of scientific samples
                 "n_eta" = n_com.fleets,
                 "n_S" = 1, # number of range and marginal variance parameters
                 
                 # covariate of the biomass field
                 "cov_x_sci"=cov_x_sci,
                 
                 "y_sci_i"=y_sci_i, # scientific CPUE
                 "t_sci_i" = (t_sci_i-1), # time step for ith observation of the scientific data
                 "q2_sci" =  1,  # scientific catchability
                 
                 "spde"=spde, # SPDE objects
                 "spde_aniso" =list(),
                 "M0"=spde$M0,
                 "M1"=spde$M1,
                 "M2"=spde$M2,
                 
                 "Aix_ij_sci"=Aix_ij_sci,
                 "Aix_w_sci"=Aix_w_sci,
                 
                 "cov_x_pred"=cov_x_pred,
                 "Aix_ij_pred"=Aix_ij_pred,
                 "Aix_w_pred"=Aix_w_pred,
                 "W"=W
    )
    
    Params = list("beta_j0"=0,
                  "beta_j0season"=rep(0,nrow(time.step_df)),
                  "beta_j0year"=rep(0,nrow(time.step_df)),
                  
                  "beta_j"=array(0,c(nrow(time.step_df),ncol(Data$cov_x_com))), # linear predictor for abundance
                  
                  "logta_S"=rep(0,1), # parameters of SPDE object (see below)
                  "logtaAR1_S"=rep(0,1), # parameters of SPDE object (see below)
                  
                  "logkappa_S"=rep(0,1),
                  "deltainput_x"=deltainput_x, # input for random noise
                  "epsiloninput_x"=deltainput_x,
                  
                  "logSigma_sci"=log(1),
                  
                  "q1_sci"=rep(0,n_survey),
                  
                  "k_sci" = 1,
                  
                  "rho_epsilon" = 0,
                  "ln_Hdelta_input" = rep(0, 2)
    )
    
    Map[["k_sci"]] <- factor(NA)
    
    
  }else if(data_source == 3){ # commercial model (commercial_only)
    
    Data = list( "options_vec"=options_vec,
                 
                 "n_x" = mesh$n, # number of cells
                 "n_t" = nrow(time.step_df), # number of time steps
                 "n_p" = nrow(loc_x),
                 "n_com_i" = length(y_com_i), # number of commercial samples
                 "n_eta" = n_com.fleets, # number of vessels
                 "n_S" = 1+n_com.fleets, # number of range and marginal variance parameters
                 
                 "cov_x_com"=cov_x_com, # covariate of the biomass field
                 "cov_fb"=if(is.null(xfb_x)){as.matrix(rep(1,nrow(cov_x_com)))}else{xfb_x}, # covariate for the commercial sampling equation
                 
                 "c_com_x"=c_com_x, # matrix of fleet counts at each time step in each cells
                 "y_com_i"=y_com_i, # commercial CPUE
                 "b_com_i" = (as.numeric(b_com_i)-1), # fleet index
                 "t_com_i" = (t_com_i-1), # time step for ith observation of the commercial data
                 "q2_com" = rep(1,length(unique(b_com_i))), # commercial catchability
                 "weights_com" = 1, # weighting factor for commercial data
                 
                 "spde"=spde, # SPDE objects
                 "spde_aniso" =list(),
                 "M0"=spde$M0,
                 "M1"=spde$M1,
                 "M2"=spde$M2,
                 
                 "Aix_ij_com"=Aix_ij_com,
                 "Aix_w_com"=Aix_w_com,
                 
                 "cov_fb_mesh"=if(is.null(xfb_x)){as.matrix(rep(1,mesh$n))}else{xfb_x},
                 
                 "cov_x_pred"=cov_x_pred,
                 "cov_fb_pred"=if(is.null(xfb_x)){as.matrix(rep(1,nrow(cov_x_pred)))}else{xfb_x},
                 "Aix_ij_pred"=Aix_ij_pred,
                 "Aix_w_pred"=Aix_w_pred,
                 "W"=W
    )
    
    Params = list("beta_j0"=0,
                  "beta_j0season"=rep(0,nrow(time.step_df)),
                  "beta_j0year"=rep(0,nrow(time.step_df)),
                  "beta_j"=array(0,c(nrow(time.step_df),ncol(Data$cov_x_com))), # linear predictor for abundance
                  "beta_fb0"=rep(0,n_com.fleets),
                  "beta_fb0season"=matrix(0,nrow = nrow(time.step_df),ncol = n_com.fleets),
                  "beta_fb0year"=matrix(0,nrow = nrow(time.step_df),ncol = n_com.fleets),
                  "beta_fb"=matrix(0,nrow = ncol(Data$cov_fb), ncol = n_com.fleets), # additionnal linear predictor for sampling intensity
                  "par_b"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_bseason"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_byear"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "par_bseasonyear"=array(0,c(nrow(time.step_df),n_com.fleets)), # link between abundance and sampling intensity
                  "logta_S"=rep(0,1+n_com.fleets), # parameters of SPDE object (see below)
                  "logtaAR1_S"=rep(0,1+n_com.fleets), # parameters of SPDE object (see below)
                  "logkappa_S"=rep(0,1+n_com.fleets),
                  "deltainput_x"=deltainput_x,
                  "epsiloninput_x"=deltainput_x,
                  "etainput_x"=etainput_x,
                  "psiinput_x"=etainput_x,
                  "logSigma_com"=rep(0,n_com.fleets),
                  "q1_com"=rep(0,n_com.fleets),
                  "k_com" = rep(1,c(n_com.fleets)),
                  "rho_epsilon" = 0,
                  "rho_psi" = 0,
                  "ln_Hdelta_input" = rep(0, 2),
                  "ln_Heta_input" = rep(0, 2)
    )
    
  }
  
  ## Random effect of the latent field
  if(biomass_temporal == 1){
    
    Map[["deltainput_x"]] <- factor(rep(NA,length(deltainput_x)))
    Random <- c(Random,"epsiloninput_x")
    Map[["logtaAR1_S"]] <- c(1) # carefull : Map of 'biomass_temporal' must be before 'sampling_temporal'
    Map[["logta_S"]] <- c(NA)
    
  }else{
    
    Map[["rho_epsilon"]] <- factor(NA)
    Map[["epsiloninput_x"]] <- factor(rep(NA,length(deltainput_x)))
    Random <- c(Random,"deltainput_x")
    Map[["logtaAR1_S"]] <- c(NA)
    Map[["logta_S"]] <- c(1) # carefull : Map of 'biomass_temporal' must be before 'sampling_temporal'
    
  }
  
  if( "spde_aniso" %in% names(Data) ) Data[['spde_aniso']] = list("n_s"=MeshList_aniso$anisotropic_spde$n.spde, "n_tri"=nrow(MeshList_aniso$anisotropic_spde$mesh$graph$tv), "Tri_Area"=MeshList_aniso$Tri_Area, "E0"=MeshList_aniso$E0, "E1"=MeshList_aniso$E1, "E2"=MeshList_aniso$E2, "TV"=MeshList_aniso$TV-1, "G0"=MeshList_aniso$anisotropic_spde$param.inla$M0, "G0_inv"=inla.as.dgTMatrix(solve(MeshList_aniso$anisotropic_spde$param.inla$M0)) )
  if(anisotropy == F) Map[["ln_Hdelta_input"]] <- factor(rep(NA, 2))
  
  # constant species habitat relationship
  Params[["beta_j"]] = matrix(rep(0,ncol(cov_x_com)),nrow=1)
  Map[["beta_j"]] = factor(matrix(rep(NA,ncol(cov_x_com)),nrow=nrow(Params[["beta_j"]])))
  
  ## Map and Random which are common to model 1 and 3 (integrated and commercial models)
  if(data_source %in% c(1,3)){
    
    # constant kappa
    Map[["logkappa_S"]] <- c(0,rep(1,n_com.fleets))
    
    ## Targeting
    Map[["par_bseason"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
    Map[["par_byear"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
    Map[["par_bseasonyear"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
    
    ## Covariates effects
    if(is.null(xfb_x) & samp_process==1){
      Map[["beta_fb"]]=factor(matrix(NA,nrow = ncol(Data$cov_fb), ncol = n_com.fleets)) # additionnal linear predictor for sampling intensity
    }
    
    
    ## Eliminate linkeage of density and sampling intensity
    if( EM=="fix_b" ){
      
      Map[["par_b"]] = factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
      Map[["par_bseason"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
      Map[["par_byear"]] <- factor(array(NA,c(nrow(time.step_df),n_com.fleets)))
      
    }
    
    ## Auto-regressive process
    if(sampling_temporal == 1){
      
      Map[["etainput_x"]] <- factor(array(NA,c(nrow(etainput_x),ncol(etainput_x),n_com.fleets)))
      Random <- c(Random,"etainput_x","psiinput_x")
      Map[["logta_S"]] <- c(Map[["logta_S"]],rep(NA,(length(Params$logta_S)-1)))
      Map[["logtaAR1_S"]] <- c(Map[["logtaAR1_S"]],seq(1:(length(Params$logta_S)-1)))
      
    }else{
      
      Map[["rho_psi"]] <- factor(NA)
      Map[["psiinput_x"]] <- factor(array(NA,c(nrow(etainput_x),ncol(etainput_x),n_com.fleets)))
      Random <- c(Random,"etainput_x")
      Map[["logta_S"]] <- c(Map[["logta_S"]],seq(1:(length(Params$logta_S)-1)))
      Map[["logtaAR1_S"]] <- c(Map[["logtaAR1_S"]],rep(NA,(length(Params$logta_S)-1)))
      
    }
    
    ## Anisotropy
    if(anisotropy == 0) Map[["ln_Heta_input"]] <- factor(rep(NA, 2))
    
    ## No sampling process
    if(samp_process == 0){
      
      Params[["etainput_x"]] = NULL
      Params[["psiinput_x"]] = NULL
      Params[["beta_fb"]] = NULL
      Params[["beta_fb0"]] = NULL
      Params[["beta_fb0year"]] = NULL
      Params[["beta_fb0season"]] = NULL
      Params[["par_b"]] = NULL
      Params[["par_byear"]] = NULL
      Params[["par_bseason"]] = NULL
      Params[["par_bseasonyear"]] = NULL
      Params[["par_bseasonyear"]] = NULL
      Params[["rho_psi"]] = NULL
      Params[["ln_Heta_input"]] = NULL
      
      if(T %in% str_detect(Random,"etainput_x")) Random = Random[-which(Random == "etainput_x")]
      if(T %in% str_detect(Random,"psiinput_x")) Random = Random[-which(Random == "psiinput_x")]
      if(T %in% str_detect(Random,"par_b")) Random = Random[-which(Random == "par_b")]
      
      Map[["logta_S"]][2:(n_com.fleets+1)]=NA
      Map[["logtaAR1_S"]][2:(n_com.fleets+1)]=rep(NA,n_com.fleets)
      Map[["logkappa_S"]][2:(n_com.fleets+1)]=rep(NA,n_com.fleets)
      Map[["beta_fb0"]]=NULL
      Map[["beta_fb0season"]]=NULL
      Map[["beta_fb0year"]]=NULL
      Map[["beta_fb"]]=NULL
      Map[["par_b"]]=NULL
      Map[["par_bseason"]]=NULL
      Map[["par_byear"]]=NULL
      Map[["par_bseasonyear"]]=NULL
      Map[["etainput_x"]] = NULL
      Map[["psiinput_x"]] = NULL
      Map[["rho_psi"]] = NULL
      Map[["rho_psi"]] = NULL
      Map[["ln_Heta_input"]] = NULL
      
    }
    
    ## Fix reference level of the first commercial fleet
    Map[["k_com"]] <- seq(1:(length(Params$k_com)))
    Map[["k_com"]][1] <- NA # reference level is the first fleet
    Map[["k_com"]] <- factor(Map[["k_com"]])
    
    if(samp_process == 1){
      
      Map[["beta_fb0"]] = factor(rep(NA,n_com.fleets))
      Map[["beta_fb0season"]] = matrix(NA,nrow = nrow(time.step_df),ncol = n_com.fleets)
      Map[["beta_fb0season"]] = factor(Map[["beta_fb0season"]])
      
    }
    
  }
  
  ## Set scientific data as reference data
  if(data_source == 1 & ref_data == "sci"){
    
    Map[["k_com"]] <- seq(1:(length(Params$k_com)))
    Map[["k_com"]] <- factor(Map[["k_com"]])
    
    Map[["k_sci"]] <- factor(NA)
    
  }
  
  ## Intercept of latent field is yearly and seasonnal
  Map[["beta_j0year"]] = as.numeric(time.step_df$Year) - (min(as.numeric(time.step_df$Year)-1))
  Map[["beta_j0year"]][which(Map[["beta_j0year"]] == 1)] = NA
  Map[["beta_j0year"]] = factor(Map[["beta_j0year"]])
  
  Map[["beta_j0season"]] = as.numeric(time.step_df[,1]) - (min(as.numeric(time.step_df[,1])-1))
  Map[["beta_j0season"]][which(Map[["beta_j0season"]] == month_ref)] = NA
  Map[["beta_j0season"]] = factor(Map[["beta_j0season"]])
  
  
  ## If scientific model
  if(data_source == 2){
    if(str_detect(Version,"com_x_sci_data")) Random = c("epsiloninput_x")
    
    if(nrow(time.step_df) == 1){
      
      Map[["beta_j0year"]] = factor(rep(NA,nrow(time.step_df)))
      Map[["beta_j0season"]] = factor(rep(NA,nrow(time.step_df)))
      Map[["ln_Hdelta_input"]] <- factor(rep(NA, 2))
      Map[["logkappa_S"]] <- NULL
      Map[["logta_S"]] <- factor(NA)
      Map[["k_sci"]] <- factor(NA)
      
    }
    
  }
  
  ## If only one time step, fix the auto-regressive parameter
  if(nrow(time.step_df) == 1) Map[["rho_epsilon"]] <- factor(NA)
  
  ## Map of logkappa_S, logta_S, logtaAR1_S
  if(data_source != 2) Map[["logkappa_S"]]=factor(Map[["logkappa_S"]])
  if(!is.null(Map[["logta_S"]])) Map[["logta_S"]]=factor(Map[["logta_S"]])
  if(!is.null(Map[["logtaAR1_S"]])) Map[["logtaAR1_S"]]=factor(Map[["logtaAR1_S"]])
  
  ## Presence-absence framework
  if(lf_link == 1){
    
    if(data_source %in% c(1,3)){
      Params$k_com <- rep(0,length(Params$k_com))
      Map$k_com <- NULL
      Map[["q1_com"]] <- factor(rep(NA,length(Params$q1_com)))
      Map[["logSigma_com"]] <- factor(rep(NA,length(Params$logSigma_com)))
    }
    
    if(data_source %in% c(1,2)){
      Params$k_sci <- rep(0,length(Params$k_sci))
      Map[["k_sci"]] <- factor(NA)
      Map[["q1_sci"]] <- factor(NA)
      Map[["logSigma_sci"]] <- factor(NA)
    }
    
    if(data_source %in% 3) Map$k_com <- factor(c(NA,1:(length(Params$k_com)-1)))
    
  }
  
  return(
    list(
      data = Data,
      map = Map,
      params = Params,
      random = Random
    )
  )
}

```

An example of the function. Only use to remove source inside the function `fm_fit_model`

```{r examples-fm_build_data_params_map, eval=FALSE}
## Settings all params

SE <- 1
data_source <- 1
data_obs <- 2
samp_process <- 0
b_constraint <- 2
const_spphab <- 1
cov_samp_process <- 0
biomass_temporal <- 1
sampling_temporal <- 0
anisotropy <- 0
lf_link <- 0
ref_data <- "com"
EM <- "est_b"
month_ref <- 1
compute_sd <- FALSE

fm_data_inputs <- readr::read_rds(system.file("examples", "part1_output_small.rds", package = "FishMap"))

species <- fm_data_inputs[["species"]]
b_com_i <- fm_data_inputs[["b_com_i"]]
mesh <- fm_data_inputs[["mesh"]]
time.step_df <- fm_data_inputs[["time.step_df"]]
loc_x <- fm_data_inputs[["loc_x"]]
y_com_i <- fm_data_inputs[["y_com_i"]]
y_sci_i <- fm_data_inputs[["y_sci_i"]]
cov_x_com <- fm_data_inputs[["cov_x_com"]]
cov_x_sci <- fm_data_inputs[["cov_x_sci"]]
c_com_x <- fm_data_inputs[["c_com_x"]]
t_com_i <- fm_data_inputs[["t_com_i"]]
t_sci_i <- fm_data_inputs[["t_sci_i"]]
spde <- fm_data_inputs[["spde"]]
Aix_ij_com <- fm_data_inputs[["Aix_ij_com"]]
Aix_w_com <- fm_data_inputs[["Aix_w_com"]]
Aix_ij_sci <- fm_data_inputs[["Aix_ij_sci"]]
Aix_w_sci <- fm_data_inputs[["Aix_w_sci"]]
cov_x_pred <- fm_data_inputs[["cov_x_pred"]]
Aix_ij_pred <- fm_data_inputs[["Aix_ij_pred"]]
Aix_w_pred <- fm_data_inputs[["Aix_w_pred"]]
W <- fm_data_inputs[["W"]]
n_survey <- fm_data_inputs[["n_survey"]]
MeshList_aniso <- fm_data_inputs[["MeshList_aniso"]]

xfb_x <- NULL # TO DELETE
weights_com <- 1 # TO DELETE

result <- fm_build_data_params_map(
  SE = SE,
  data_source = data_source,
  data_obs = data_obs,
  samp_process = samp_process,
  b_constraint = b_constraint,
  cov_samp_process = cov_samp_process,
  const_spphab = const_spphab,
  biomass_temporal = biomass_temporal,
  sampling_temporal = sampling_temporal,
  anisotropy = anisotropy,
  lf_link = lf_link,
  b_com_i = b_com_i,
  mesh = mesh,
  time.step_df = time.step_df,
  loc_x = loc_x,
  y_com_i = y_com_i,
  y_sci_i = y_sci_i,
  cov_x_com = cov_x_com,
  cov_x_sci = cov_x_sci,
  xfb_x = xfb_x,
  c_com_x = c_com_x,
  t_com_i = t_com_i,
  weights_com = weights_com,
  t_sci_i = t_sci_i,
  spde = spde,
  Aix_ij_com = Aix_ij_com,
  Aix_w_com = Aix_w_com,
  Aix_ij_sci = Aix_ij_sci,
  Aix_w_sci = Aix_w_sci,
  cov_x_pred = cov_x_pred,
  Aix_ij_pred = Aix_ij_pred,
  Aix_w_pred = Aix_w_pred,
  W = W,
  n_survey = n_survey,
  MeshList_aniso = MeshList_aniso,
  EM = EM,
  ref_data = ref_data,
  month_ref = month_ref,
  Version = Version
)
```



```{r tests-fm_build_data_params_map}
test_that("fm_build_data_params_map", {
  
  ## Settings all params
  
  SE <- 1
  data_source <- 1
  data_obs <- 2
  samp_process <- 0
  b_constraint <- 2
  const_spphab <- 1
  cov_samp_process <- 0
  biomass_temporal <- 1
  sampling_temporal <- 0
  anisotropy <- 0
  lf_link <- 0
  ref_data <- "com"
  EM <- "est_b"
  month_ref <- 1
  compute_sd <- FALSE
  
  fm_data_inputs <- readr::read_rds(system.file("examples", "part1_output_small.rds", package = "FishMap"))
  
  species <- fm_data_inputs[["species"]]
  b_com_i <- fm_data_inputs[["b_com_i"]]
  mesh <- fm_data_inputs[["mesh"]]
  time.step_df <- fm_data_inputs[["time.step_df"]]
  loc_x <- fm_data_inputs[["loc_x"]]
  y_com_i <- fm_data_inputs[["y_com_i"]]
  y_sci_i <- fm_data_inputs[["y_sci_i"]]
  cov_x_com <- fm_data_inputs[["cov_x_com"]]
  cov_x_sci <- fm_data_inputs[["cov_x_sci"]]
  c_com_x <- fm_data_inputs[["c_com_x"]]
  t_com_i <- fm_data_inputs[["t_com_i"]]
  t_sci_i <- fm_data_inputs[["t_sci_i"]]
  spde <- fm_data_inputs[["spde"]]
  Aix_ij_com <- fm_data_inputs[["Aix_ij_com"]]
  Aix_w_com <- fm_data_inputs[["Aix_w_com"]]
  Aix_ij_sci <- fm_data_inputs[["Aix_ij_sci"]]
  Aix_w_sci <- fm_data_inputs[["Aix_w_sci"]]
  cov_x_pred <- fm_data_inputs[["cov_x_pred"]]
  Aix_ij_pred <- fm_data_inputs[["Aix_ij_pred"]]
  Aix_w_pred <- fm_data_inputs[["Aix_w_pred"]]
  W <- fm_data_inputs[["W"]]
  n_survey <- fm_data_inputs[["n_survey"]]
  MeshList_aniso <- fm_data_inputs[["MeshList_aniso"]]
  
  xfb_x <- NULL # TO DELETE
  weights_com <- 1 # TO DELETE
  
  result <- fm_build_data_params_map(
    SE = SE,
    data_source = data_source,
    data_obs = data_obs,
    samp_process = samp_process,
    b_constraint = b_constraint,
    cov_samp_process = cov_samp_process,
    const_spphab = const_spphab,
    biomass_temporal = biomass_temporal,
    sampling_temporal = sampling_temporal,
    anisotropy = anisotropy,
    lf_link = lf_link,
    b_com_i = b_com_i,
    mesh = mesh,
    time.step_df = time.step_df,
    loc_x = loc_x,
    y_com_i = y_com_i,
    y_sci_i = y_sci_i,
    cov_x_com = cov_x_com,
    cov_x_sci = cov_x_sci,
    xfb_x = xfb_x,
    c_com_x = c_com_x,
    t_com_i = t_com_i,
    weights_com = weights_com,
    t_sci_i = t_sci_i,
    spde = spde,
    Aix_ij_com = Aix_ij_com,
    Aix_w_com = Aix_w_com,
    Aix_ij_sci = Aix_ij_sci,
    Aix_w_sci = Aix_w_sci,
    cov_x_pred = cov_x_pred,
    Aix_ij_pred = Aix_ij_pred,
    Aix_w_pred = Aix_w_pred,
    W = W,
    n_survey = n_survey,
    MeshList_aniso = MeshList_aniso,
    EM = EM,
    ref_data = ref_data,
    month_ref = month_ref,
    Version = Version
  )
  
  #' @description Testing that fm_build_data_params_map return a list
  expect_type(object = result, "list")
  
  #' @description Testing names of the list
  expect_named(result, c("data", "map", "params", "random"))
  
})
```


# `fm_fit_model()`: compile model and fit to data

This function will fit the model to the observation data. It will compile the model cpp file. It will fit the model to the input data generated from `fm_load_data()` and provide the results as a named list.


```{r function-fm_fit_model }
#' Compile model and fit to data
#'
#' @param fm_data_inputs list Named list obtained from `fm_load_data()`
#' @param SE  Numeric. Apply bias correction and compute standard errors for key quantities of interest (spatial predictions and total biomass). N.b. can be very time consuming. - 0: no, 1: yes
#' @param data_source Numeric. Specify the data sources used to fit the model.	1 : integrated model (scientific + commercial data) ; 2 : scientific model ; 3 : commercial model
#' @param data_obs Numeric. Observation model for biomass.	1 : zero-inflated gamma ; 2 : zero-inflated lognormal ; 3 : lognormal
#' @param samp_process Numeric. Include sampling process or not.	0 : no sampling process (faster) ; 1 : inhomogeneous Poisson point process
#' @param b_constraint Numeric. Put constraint on b parameters.	1 : b are positives ; 2 : no constraints
#' @param cov_samp_process Numeric. Covariates in the sampling process.	0 : none ; 1 : covariates in the sampling process
#' @param biomass_temporal Numeric. Temporal correlation in biomass.	0 : no ; 1 : first-order autoregressive model (AR1)
#' @param sampling_temporal Numeric. Temporal correlation in sampling process.	0 : no ; 1 : first-order autoregressive model (AR1)
#' @param lf_link Numeric. Link function of the latent field.	0 : log (biomass data) ; 1 : logit (presence absence data)
#' @param ref_data character. Reference data for estimating the interecept of the latent field.	com : commercial (default) ; sci : scientific
#' @param EM character. Reference data for estimating the intercept of the latent field.	est_b : b is estimated ; fix_b : b is fixed
#' @param month_ref numeric.	Reference month	1 to 12
#' @param compute_sd logical	run sdreport().	TRUE ; FALSE
#' @param Version version for fm_build_data_params_map
#' @param seed integer The seed controlling for random effect. Default is 29510.
#'
#' @importFrom stats nlminb
#' @importFrom stringr str_detect
#' @importFrom tictoc tic toc
#' @importFrom TMB compile dynlib MakeADFun sdreport
#  source build_data_params_map
#' @importFrom INLA inla.as.dgTMatrix
#' @importFrom stringr str_detect
#' 
#' @return list A named list of all necessary outputs for generating graphs (step 3)
#' @export
#'
#' @examples
fm_fit_model <- function(fm_data_inputs,
                         SE,
                         data_source,
                         data_obs,
                         samp_process,
                         b_constraint,
                         cov_samp_process,
                         biomass_temporal,
                         sampling_temporal,
                         lf_link,
                         ref_data = c("com", "sci"),
                         EM = c("est_b","fix_b"),
                         month_ref,
                         compute_sd = FALSE,
                         Version = "",
                         seed = 29510) {
  
  ## Check Params
  
  ref_data <- match.arg(ref_data)
  EM <- match.arg(EM)
  
  const_spphab <- 1
  anisotropy <- 0
  
  ## Fit model
  #-----------
  message("Running step 2 -compile model-")
  tic("Step 2 -compile model-")
  
  withr::local_seed(seed = seed)
    
    
    ## Dependencies from Part1 outputs
    species <- fm_data_inputs[["species"]]
    b_com_i <- fm_data_inputs[["b_com_i"]]
    mesh <- fm_data_inputs[["mesh"]]
    time.step_df <- fm_data_inputs[["time.step_df"]]
    loc_x <- fm_data_inputs[["loc_x"]]
    y_com_i <- fm_data_inputs[["y_com_i"]]
    y_sci_i <- fm_data_inputs[["y_sci_i"]]
    cov_x_com <- fm_data_inputs[["cov_x_com"]]
    cov_x_sci <- fm_data_inputs[["cov_x_sci"]]
    c_com_x <- fm_data_inputs[["c_com_x"]]
    t_com_i <- fm_data_inputs[["t_com_i"]]
    t_sci_i <- fm_data_inputs[["t_sci_i"]]
    spde <- fm_data_inputs[["spde"]]
    Aix_ij_com <- fm_data_inputs[["Aix_ij_com"]]
    Aix_w_com <- fm_data_inputs[["Aix_w_com"]]
    Aix_ij_sci <- fm_data_inputs[["Aix_ij_sci"]]
    Aix_w_sci <- fm_data_inputs[["Aix_w_sci"]]
    cov_x_pred <- fm_data_inputs[["cov_x_pred"]]
    Aix_ij_pred <- fm_data_inputs[["Aix_ij_pred"]]
    Aix_w_pred <- fm_data_inputs[["Aix_w_pred"]]
    W <- fm_data_inputs[["W"]]
    n_survey <- fm_data_inputs[["n_survey"]]
    MeshList_aniso <- fm_data_inputs[["MeshList_aniso"]]
    
    # script location
    data_folder <- system.file(file.path("original_data",species), package = "FishMap")
    script_folder <- system.file("original_scripts", package = "FishMap")
    
    xfb_x <- NULL # TO DELETE
    weights_com <- 1 # TO DELETE
    
    ## Build Data, Params and Map objects for model fitting
    data_params_map_random <- fm_build_data_params_map(
      SE = SE,
      data_source = data_source,
      data_obs = data_obs,
      samp_process = samp_process,
      b_constraint = b_constraint,
      cov_samp_process = cov_samp_process,
      const_spphab = const_spphab,
      biomass_temporal = biomass_temporal,
      sampling_temporal = sampling_temporal,
      anisotropy = anisotropy,
      lf_link = lf_link,
      b_com_i = b_com_i,
      mesh = mesh,
      time.step_df = time.step_df,
      loc_x = loc_x,
      y_com_i = y_com_i,
      y_sci_i = y_sci_i,
      cov_x_com = cov_x_com,
      cov_x_sci = cov_x_sci,
      xfb_x = xfb_x,
      c_com_x = c_com_x,
      t_com_i = t_com_i,
      weights_com = weights_com,
      t_sci_i = t_sci_i,
      spde = spde,
      Aix_ij_com = Aix_ij_com,
      Aix_w_com = Aix_w_com,
      Aix_ij_sci = Aix_ij_sci,
      Aix_w_sci = Aix_w_sci,
      cov_x_pred = cov_x_pred,
      Aix_ij_pred = Aix_ij_pred,
      Aix_w_pred = Aix_w_pred,
      W = W,
      n_survey = n_survey,
      MeshList_aniso = MeshList_aniso,
      EM = EM,
      ref_data = ref_data,
      month_ref = month_ref,
      Version = Version
    )
    
    # define global var
    Data <- data_params_map_random$data
    Params <- data_params_map_random$params
    Map <- data_params_map_random$map
    Random <- data_params_map_random$random
    
    # Add link to path
    if (.Platform$OS.type == "windows"){
      fixwinpath <- function(){
        PATH <- Sys.getenv("PATH")
        PATH <- paste0(R.home(), "/bin/x64;", PATH)
        PATH <- paste0("c:/Rtools/mingw64/bin;", PATH)
        Sys.setenv(PATH=PATH)
      }
      fixwinpath()
      shell("where g++")
      shell("where gdb")
      shell("where Rterm")
    }
    
    ## Model compilation
    compile(system.file("model.cpp", package = "FishMap"),"-O1 -g",DLLFLAGS="")
    dyn.load( dynlib(file.path(system.file(package = "FishMap"),"model") ))
    
    # finished step 2 -compile model-
    toc()
    
    ## Fit model
    message("Running step 3 -fit model-")
    tic("Step 3 -fit model-")
    
    # ## Debugging
    # source("r/function/MakeADFun_windows_debug.R")
    # MakeADFun_windows_debug(cpp_name = "inst/model",  data=Data, parameters=Params,  random=Random)
    # gdbsource("inst/model.R",interactive = T) ## Non-interactive
    # dyn.unload( dynlib( "inst/model" ) )
    # #-----------
    
    obj = MakeADFun( data=Data, parameters=Params,  random=Random, map = Map, silent = TRUE,hessian = TRUE )
    # next line takes a long time ----
    obj$fn( obj$par )
    
    # Parameters boundary for optimization
    Lower <- -50
    Upper <- 50
    
    if(T %in% str_detect(names(obj$par),"rho_")){ # constraints on the bounds of rho
      
      Lower <- rep(-50,length(obj$par))
      Upper <- rep(50,length(obj$par))
      
      Lower[which(str_detect(names(obj$par),"rho_"))] <- -0.99
      Upper[which(str_detect(names(obj$par),"rho_"))] <- 0.99
      
    }
    
    # next line takes a VERY long time ----
    opt = nlminb( start=obj$par, objective=obj$fn, gradient=obj$gr, lower=Lower, upper=Upper, control=list(trace=1, maxit=200))
    opt[["diagnostics"]] = data.frame( "Param"=names(obj$par), "Lower"=-Inf, "Est"=opt$par, "Upper"=Inf, "gradient"=obj$gr(opt$par) )
    
    report = obj$report() # output values
    converge=opt$convergence # convergence test
    # next line takes a VERY long time ----
    if(compute_sd) SD = sdreport(obj,bias.correct=FALSE,ignore.parm.uncertainty=TRUE) # compute standard deviation
    
    dyn.unload( dynlib( file.path(system.file(package = "FishMap"),"model")))
  
  # Finished step 3 - fit model-
  toc()
  
  # return outputs as named list
  return(list("time.step_df" = time.step_df,
              "loc_x" = loc_x,
              "report" = report,
              "samp_process" = samp_process,
              "converge" = converge
  )
  )
  
}
```

```{r examples-fm_fit_model, eval=FALSE}
# run part 2
fm_data_inputs <- readr::read_rds(system.file("examples", "part1_output_small.rds", package = "FishMap"))
fm_model_results <- fm_fit_model(fm_data_inputs = fm_data_inputs,
                                 SE = 1,
                                 data_source = 1,
                                 data_obs = 2,
                                 samp_process = 0,
                                 b_constraint = 2,
                                 cov_samp_process = 0,
                                 biomass_temporal = 1,
                                 sampling_temporal = 0,
                                 lf_link = 0,
                                 ref_data = "com",
                                 EM = "est_b",
                                 month_ref = 1)
```

```{r tests-fm_fit_model}
test_that("fm_fit_model works", {
  
  
  # You can test your model for small datas or big datas. You must run the tests locally with FISHMAP_UPDATE_OUTPUTS env at TRUE to store the rds file.
  
  test_resolution <- Sys.getenv("FISHMAP_TEST_RESOLUTION", unset = "small")
  
  if(test_resolution == "small"){
    fm_data_inputs <- readr::read_rds(system.file("examples", "part1_output_small.rds", package = "FishMap"))
  }else if (test_resolution == "big") {
    ## TODO use correct params for line below
    # fm_data_inputs <- fm_load_data(k = 0.75, month_start = 10, month_end = 12, ...)
  }
  
  
  
  # run part2
  withr::with_seed(1234,{
    

  fm_model_results <- fm_fit_model(fm_data_inputs = fm_data_inputs,
                                   SE = 1,
                                   data_source = 1,
                                   data_obs = 2,
                                   samp_process = 0,
                                   b_constraint = 2,
                                   cov_samp_process = 0,
                                   biomass_temporal = 1,
                                   sampling_temporal = 0,
                                   lf_link = 0,
                                   ref_data = "com",
                                   EM = "est_b",
                                   month_ref = 1)
  
  })
  
  # Update expected outputs here
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    # save output depending if we are in flat or in test
    output_inst_dir <- here::here("inst", "examples") 
    
    if (test_resolution == "small") {
      readr::write_rds(x = fm_model_results,
                       file = file.path(output_inst_dir, paste0("part2_output_", test_resolution , ".rds")))
    }else if (test_resolution == "big") {
      ## TODO what we need to check
    }
    
  }
  
  # check output is saved as rds
  if (Sys.getenv("FISHMAP_UPDATE_TEST_OUTPUTS") == "TRUE") {
    
    
    output_inst_dir <- here::here("inst", "examples")
    
    #' @description Test to check if we can save output
    expect_true(file.exists(file.path(output_inst_dir, paste0("part2_output_", test_resolution , ".rds"))))
  }
  
  # Check resultats of model 
  
  #' @description Testing the result of `fm_fit_model` is a list
  expect_type(object = fm_model_results,  "list")
  
  #' @description Testing names of the list return by `fm_fit_model` 
  expect_named(
    object = fm_model_results, 
    expected = c(
      "time.step_df", 
      "loc_x" ,      
      "report" ,   
      "samp_process", 
      "converge" )
  )
  
  
  #' @description Testing types inside the list return by `fm_fit_model` 
  expect_s3_class(fm_model_results$time.step_df, "data.frame")
  expect_s3_class(fm_model_results$loc_x, "data.frame")
  expect_type(fm_model_results$report, "list")
  expect_type(fm_model_results$samp_process, "double")
  expect_type(fm_model_results$converge, "integer")
  
  # Testing for small model
  
  if(test_resolution == "small"){
    
    expected_outputs <- readr::read_rds(
      system.file(
        "examples",
        paste0("part2_output_", test_resolution , ".rds"),
        package = "FishMap")
    )
    
    
    # sort list and data frame elements to avoid order discrepancies
    resort_all <- function(x) {
      x <- x[sort(names(x))]
      
      result <- lapply(x, function(x) {
        if (inherits(x, c("data.frame", 'list'))) {
          x[sort(names(x))]
        } else{
          x
        }
      })
      
      result
    }
    
    resorted_result <- resort_all(fm_model_results)
    resorted_expected <- resort_all(expected_outputs)
    
    # remove name attributes (likely generated by a specific version of {sf})
    attr(resorted_result$loc_x$long, which = "names") <- NULL
    attr(resorted_result$loc_x$lati, which = "names") <- NULL
    attr(resorted_expected$loc_x$long, which = "names") <- NULL
    attr(resorted_expected$loc_x$lati, which = "names") <- NULL
    
    #' @description Testing that the result of `fm_fit_model` is stable
    expect_equal(
      object = resorted_result,
      expected = resorted_expected,
      tolerance = 1e-4
    )
  }
  
})
```


```{r development-inflate, eval=FALSE}
# Run but keep eval=FALSE to avoid infinite loop
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_fm_fit_model.Rmd", vignette_name = "Dev - Fit Model", check = FALSE)
```
